// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brpc/rtmp.proto

#ifndef PROTOBUF_INCLUDED_brpc_2frtmp_2eproto
#define PROTOBUF_INCLUDED_brpc_2frtmp_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_brpc_2frtmp_2eproto 

namespace protobuf_brpc_2frtmp_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_brpc_2frtmp_2eproto
namespace brpc {
class RtmpConnectRequest;
class RtmpConnectRequestDefaultTypeInternal;
extern RtmpConnectRequestDefaultTypeInternal _RtmpConnectRequest_default_instance_;
class RtmpConnectResponse;
class RtmpConnectResponseDefaultTypeInternal;
extern RtmpConnectResponseDefaultTypeInternal _RtmpConnectResponse_default_instance_;
class RtmpEmptyObject;
class RtmpEmptyObjectDefaultTypeInternal;
extern RtmpEmptyObjectDefaultTypeInternal _RtmpEmptyObject_default_instance_;
class RtmpInfo;
class RtmpInfoDefaultTypeInternal;
extern RtmpInfoDefaultTypeInternal _RtmpInfo_default_instance_;
class RtmpPlay2Options;
class RtmpPlay2OptionsDefaultTypeInternal;
extern RtmpPlay2OptionsDefaultTypeInternal _RtmpPlay2Options_default_instance_;
}  // namespace brpc
namespace google {
namespace protobuf {
template<> ::brpc::RtmpConnectRequest* Arena::CreateMaybeMessage<::brpc::RtmpConnectRequest>(Arena*);
template<> ::brpc::RtmpConnectResponse* Arena::CreateMaybeMessage<::brpc::RtmpConnectResponse>(Arena*);
template<> ::brpc::RtmpEmptyObject* Arena::CreateMaybeMessage<::brpc::RtmpEmptyObject>(Arena*);
template<> ::brpc::RtmpInfo* Arena::CreateMaybeMessage<::brpc::RtmpInfo>(Arena*);
template<> ::brpc::RtmpPlay2Options* Arena::CreateMaybeMessage<::brpc::RtmpPlay2Options>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace brpc {

// ===================================================================

class RtmpConnectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpConnectRequest) */ {
 public:
  RtmpConnectRequest();
  virtual ~RtmpConnectRequest();

  RtmpConnectRequest(const RtmpConnectRequest& from);

  inline RtmpConnectRequest& operator=(const RtmpConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RtmpConnectRequest(RtmpConnectRequest&& from) noexcept
    : RtmpConnectRequest() {
    *this = ::std::move(from);
  }

  inline RtmpConnectRequest& operator=(RtmpConnectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpConnectRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RtmpConnectRequest* internal_default_instance() {
    return reinterpret_cast<const RtmpConnectRequest*>(
               &_RtmpConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RtmpConnectRequest* other);
  friend void swap(RtmpConnectRequest& a, RtmpConnectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RtmpConnectRequest* New() const final {
    return CreateMaybeMessage<RtmpConnectRequest>(NULL);
  }

  RtmpConnectRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RtmpConnectRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RtmpConnectRequest& from);
  void MergeFrom(const RtmpConnectRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpConnectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string app = 1;
  bool has_app() const;
  void clear_app();
  static const int kAppFieldNumber = 1;
  const ::std::string& app() const;
  void set_app(const ::std::string& value);
  #if LANG_CXX11
  void set_app(::std::string&& value);
  #endif
  void set_app(const char* value);
  void set_app(const char* value, size_t size);
  ::std::string* mutable_app();
  ::std::string* release_app();
  void set_allocated_app(::std::string* app);

  // optional string flashVer = 2;
  bool has_flashver() const;
  void clear_flashver();
  static const int kFlashVerFieldNumber = 2;
  const ::std::string& flashver() const;
  void set_flashver(const ::std::string& value);
  #if LANG_CXX11
  void set_flashver(::std::string&& value);
  #endif
  void set_flashver(const char* value);
  void set_flashver(const char* value, size_t size);
  ::std::string* mutable_flashver();
  ::std::string* release_flashver();
  void set_allocated_flashver(::std::string* flashver);

  // optional string swfUrl = 3;
  bool has_swfurl() const;
  void clear_swfurl();
  static const int kSwfUrlFieldNumber = 3;
  const ::std::string& swfurl() const;
  void set_swfurl(const ::std::string& value);
  #if LANG_CXX11
  void set_swfurl(::std::string&& value);
  #endif
  void set_swfurl(const char* value);
  void set_swfurl(const char* value, size_t size);
  ::std::string* mutable_swfurl();
  ::std::string* release_swfurl();
  void set_allocated_swfurl(::std::string* swfurl);

  // optional string tcUrl = 4;
  bool has_tcurl() const;
  void clear_tcurl();
  static const int kTcUrlFieldNumber = 4;
  const ::std::string& tcurl() const;
  void set_tcurl(const ::std::string& value);
  #if LANG_CXX11
  void set_tcurl(::std::string&& value);
  #endif
  void set_tcurl(const char* value);
  void set_tcurl(const char* value, size_t size);
  ::std::string* mutable_tcurl();
  ::std::string* release_tcurl();
  void set_allocated_tcurl(::std::string* tcurl);

  // optional string pageUrl = 10;
  bool has_pageurl() const;
  void clear_pageurl();
  static const int kPageUrlFieldNumber = 10;
  const ::std::string& pageurl() const;
  void set_pageurl(const ::std::string& value);
  #if LANG_CXX11
  void set_pageurl(::std::string&& value);
  #endif
  void set_pageurl(const char* value);
  void set_pageurl(const char* value, size_t size);
  ::std::string* mutable_pageurl();
  ::std::string* release_pageurl();
  void set_allocated_pageurl(::std::string* pageurl);

  // optional double capabilities = 6;
  bool has_capabilities() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 6;
  double capabilities() const;
  void set_capabilities(double value);

  // optional double audioCodecs = 7;
  bool has_audiocodecs() const;
  void clear_audiocodecs();
  static const int kAudioCodecsFieldNumber = 7;
  double audiocodecs() const;
  void set_audiocodecs(double value);

  // optional double videoCodecs = 8;
  bool has_videocodecs() const;
  void clear_videocodecs();
  static const int kVideoCodecsFieldNumber = 8;
  double videocodecs() const;
  void set_videocodecs(double value);

  // optional double videoFunction = 9;
  bool has_videofunction() const;
  void clear_videofunction();
  static const int kVideoFunctionFieldNumber = 9;
  double videofunction() const;
  void set_videofunction(double value);

  // optional double objectEncoding = 11;
  bool has_objectencoding() const;
  void clear_objectencoding();
  static const int kObjectEncodingFieldNumber = 11;
  double objectencoding() const;
  void set_objectencoding(double value);

  // optional bool fpad = 5;
  bool has_fpad() const;
  void clear_fpad();
  static const int kFpadFieldNumber = 5;
  bool fpad() const;
  void set_fpad(bool value);

  // optional bool stream_multiplexing = 12;
  bool has_stream_multiplexing() const;
  void clear_stream_multiplexing();
  static const int kStreamMultiplexingFieldNumber = 12;
  bool stream_multiplexing() const;
  void set_stream_multiplexing(bool value);

  // @@protoc_insertion_point(class_scope:brpc.RtmpConnectRequest)
 private:
  void set_has_app();
  void clear_has_app();
  void set_has_flashver();
  void clear_has_flashver();
  void set_has_swfurl();
  void clear_has_swfurl();
  void set_has_tcurl();
  void clear_has_tcurl();
  void set_has_fpad();
  void clear_has_fpad();
  void set_has_capabilities();
  void clear_has_capabilities();
  void set_has_audiocodecs();
  void clear_has_audiocodecs();
  void set_has_videocodecs();
  void clear_has_videocodecs();
  void set_has_videofunction();
  void clear_has_videofunction();
  void set_has_pageurl();
  void clear_has_pageurl();
  void set_has_objectencoding();
  void clear_has_objectencoding();
  void set_has_stream_multiplexing();
  void clear_has_stream_multiplexing();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr app_;
  ::google::protobuf::internal::ArenaStringPtr flashver_;
  ::google::protobuf::internal::ArenaStringPtr swfurl_;
  ::google::protobuf::internal::ArenaStringPtr tcurl_;
  ::google::protobuf::internal::ArenaStringPtr pageurl_;
  double capabilities_;
  double audiocodecs_;
  double videocodecs_;
  double videofunction_;
  double objectencoding_;
  bool fpad_;
  bool stream_multiplexing_;
  friend struct ::protobuf_brpc_2frtmp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RtmpConnectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpConnectResponse) */ {
 public:
  RtmpConnectResponse();
  virtual ~RtmpConnectResponse();

  RtmpConnectResponse(const RtmpConnectResponse& from);

  inline RtmpConnectResponse& operator=(const RtmpConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RtmpConnectResponse(RtmpConnectResponse&& from) noexcept
    : RtmpConnectResponse() {
    *this = ::std::move(from);
  }

  inline RtmpConnectResponse& operator=(RtmpConnectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpConnectResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RtmpConnectResponse* internal_default_instance() {
    return reinterpret_cast<const RtmpConnectResponse*>(
               &_RtmpConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RtmpConnectResponse* other);
  friend void swap(RtmpConnectResponse& a, RtmpConnectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RtmpConnectResponse* New() const final {
    return CreateMaybeMessage<RtmpConnectResponse>(NULL);
  }

  RtmpConnectResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RtmpConnectResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RtmpConnectResponse& from);
  void MergeFrom(const RtmpConnectResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpConnectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fmsVer = 1;
  bool has_fmsver() const;
  void clear_fmsver();
  static const int kFmsVerFieldNumber = 1;
  const ::std::string& fmsver() const;
  void set_fmsver(const ::std::string& value);
  #if LANG_CXX11
  void set_fmsver(::std::string&& value);
  #endif
  void set_fmsver(const char* value);
  void set_fmsver(const char* value, size_t size);
  ::std::string* mutable_fmsver();
  ::std::string* release_fmsver();
  void set_allocated_fmsver(::std::string* fmsver);

  // optional double capabilities = 2;
  bool has_capabilities() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 2;
  double capabilities() const;
  void set_capabilities(double value);

  // optional double mode = 3;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  double mode() const;
  void set_mode(double value);

  // optional bool create_stream_with_play_or_publish = 4;
  bool has_create_stream_with_play_or_publish() const;
  void clear_create_stream_with_play_or_publish();
  static const int kCreateStreamWithPlayOrPublishFieldNumber = 4;
  bool create_stream_with_play_or_publish() const;
  void set_create_stream_with_play_or_publish(bool value);

  // @@protoc_insertion_point(class_scope:brpc.RtmpConnectResponse)
 private:
  void set_has_fmsver();
  void clear_has_fmsver();
  void set_has_capabilities();
  void clear_has_capabilities();
  void set_has_mode();
  void clear_has_mode();
  void set_has_create_stream_with_play_or_publish();
  void clear_has_create_stream_with_play_or_publish();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fmsver_;
  double capabilities_;
  double mode_;
  bool create_stream_with_play_or_publish_;
  friend struct ::protobuf_brpc_2frtmp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RtmpPlay2Options : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpPlay2Options) */ {
 public:
  RtmpPlay2Options();
  virtual ~RtmpPlay2Options();

  RtmpPlay2Options(const RtmpPlay2Options& from);

  inline RtmpPlay2Options& operator=(const RtmpPlay2Options& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RtmpPlay2Options(RtmpPlay2Options&& from) noexcept
    : RtmpPlay2Options() {
    *this = ::std::move(from);
  }

  inline RtmpPlay2Options& operator=(RtmpPlay2Options&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpPlay2Options& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RtmpPlay2Options* internal_default_instance() {
    return reinterpret_cast<const RtmpPlay2Options*>(
               &_RtmpPlay2Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RtmpPlay2Options* other);
  friend void swap(RtmpPlay2Options& a, RtmpPlay2Options& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RtmpPlay2Options* New() const final {
    return CreateMaybeMessage<RtmpPlay2Options>(NULL);
  }

  RtmpPlay2Options* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RtmpPlay2Options>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RtmpPlay2Options& from);
  void MergeFrom(const RtmpPlay2Options& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpPlay2Options* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string oldStreamName = 3;
  bool has_oldstreamname() const;
  void clear_oldstreamname();
  static const int kOldStreamNameFieldNumber = 3;
  const ::std::string& oldstreamname() const;
  void set_oldstreamname(const ::std::string& value);
  #if LANG_CXX11
  void set_oldstreamname(::std::string&& value);
  #endif
  void set_oldstreamname(const char* value);
  void set_oldstreamname(const char* value, size_t size);
  ::std::string* mutable_oldstreamname();
  ::std::string* release_oldstreamname();
  void set_allocated_oldstreamname(::std::string* oldstreamname);

  // optional string streamName = 5;
  bool has_streamname() const;
  void clear_streamname();
  static const int kStreamNameFieldNumber = 5;
  const ::std::string& streamname() const;
  void set_streamname(const ::std::string& value);
  #if LANG_CXX11
  void set_streamname(::std::string&& value);
  #endif
  void set_streamname(const char* value);
  void set_streamname(const char* value, size_t size);
  ::std::string* mutable_streamname();
  ::std::string* release_streamname();
  void set_allocated_streamname(::std::string* streamname);

  // optional string transition = 6;
  bool has_transition() const;
  void clear_transition();
  static const int kTransitionFieldNumber = 6;
  const ::std::string& transition() const;
  void set_transition(const ::std::string& value);
  #if LANG_CXX11
  void set_transition(::std::string&& value);
  #endif
  void set_transition(const char* value);
  void set_transition(const char* value, size_t size);
  ::std::string* mutable_transition();
  ::std::string* release_transition();
  void set_allocated_transition(::std::string* transition);

  // optional double len = 1;
  bool has_len() const;
  void clear_len();
  static const int kLenFieldNumber = 1;
  double len() const;
  void set_len(double value);

  // optional double offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  double offset() const;
  void set_offset(double value);

  // optional double start = 4;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 4;
  double start() const;
  void set_start(double value);

  // @@protoc_insertion_point(class_scope:brpc.RtmpPlay2Options)
 private:
  void set_has_len();
  void clear_has_len();
  void set_has_offset();
  void clear_has_offset();
  void set_has_oldstreamname();
  void clear_has_oldstreamname();
  void set_has_start();
  void clear_has_start();
  void set_has_streamname();
  void clear_has_streamname();
  void set_has_transition();
  void clear_has_transition();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr oldstreamname_;
  ::google::protobuf::internal::ArenaStringPtr streamname_;
  ::google::protobuf::internal::ArenaStringPtr transition_;
  double len_;
  double offset_;
  double start_;
  friend struct ::protobuf_brpc_2frtmp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RtmpInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpInfo) */ {
 public:
  RtmpInfo();
  virtual ~RtmpInfo();

  RtmpInfo(const RtmpInfo& from);

  inline RtmpInfo& operator=(const RtmpInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RtmpInfo(RtmpInfo&& from) noexcept
    : RtmpInfo() {
    *this = ::std::move(from);
  }

  inline RtmpInfo& operator=(RtmpInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RtmpInfo* internal_default_instance() {
    return reinterpret_cast<const RtmpInfo*>(
               &_RtmpInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RtmpInfo* other);
  friend void swap(RtmpInfo& a, RtmpInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RtmpInfo* New() const final {
    return CreateMaybeMessage<RtmpInfo>(NULL);
  }

  RtmpInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RtmpInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RtmpInfo& from);
  void MergeFrom(const RtmpInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // optional string level = 2;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  const ::std::string& level() const;
  void set_level(const ::std::string& value);
  #if LANG_CXX11
  void set_level(::std::string&& value);
  #endif
  void set_level(const char* value);
  void set_level(const char* value, size_t size);
  ::std::string* mutable_level();
  ::std::string* release_level();
  void set_allocated_level(::std::string* level);

  // optional string description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional double objectEncoding = 4;
  bool has_objectencoding() const;
  void clear_objectencoding();
  static const int kObjectEncodingFieldNumber = 4;
  double objectencoding() const;
  void set_objectencoding(double value);

  // @@protoc_insertion_point(class_scope:brpc.RtmpInfo)
 private:
  void set_has_code();
  void clear_has_code();
  void set_has_level();
  void clear_has_level();
  void set_has_description();
  void clear_has_description();
  void set_has_objectencoding();
  void clear_has_objectencoding();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr level_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  double objectencoding_;
  friend struct ::protobuf_brpc_2frtmp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RtmpEmptyObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpEmptyObject) */ {
 public:
  RtmpEmptyObject();
  virtual ~RtmpEmptyObject();

  RtmpEmptyObject(const RtmpEmptyObject& from);

  inline RtmpEmptyObject& operator=(const RtmpEmptyObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RtmpEmptyObject(RtmpEmptyObject&& from) noexcept
    : RtmpEmptyObject() {
    *this = ::std::move(from);
  }

  inline RtmpEmptyObject& operator=(RtmpEmptyObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtmpEmptyObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RtmpEmptyObject* internal_default_instance() {
    return reinterpret_cast<const RtmpEmptyObject*>(
               &_RtmpEmptyObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RtmpEmptyObject* other);
  friend void swap(RtmpEmptyObject& a, RtmpEmptyObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RtmpEmptyObject* New() const final {
    return CreateMaybeMessage<RtmpEmptyObject>(NULL);
  }

  RtmpEmptyObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RtmpEmptyObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RtmpEmptyObject& from);
  void MergeFrom(const RtmpEmptyObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpEmptyObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:brpc.RtmpEmptyObject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_brpc_2frtmp_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RtmpConnectRequest

// optional string app = 1;
inline bool RtmpConnectRequest::has_app() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtmpConnectRequest::set_has_app() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtmpConnectRequest::clear_has_app() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtmpConnectRequest::clear_app() {
  app_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app();
}
inline const ::std::string& RtmpConnectRequest::app() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.app)
  return app_.GetNoArena();
}
inline void RtmpConnectRequest::set_app(const ::std::string& value) {
  set_has_app();
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.app)
}
#if LANG_CXX11
inline void RtmpConnectRequest::set_app(::std::string&& value) {
  set_has_app();
  app_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpConnectRequest.app)
}
#endif
inline void RtmpConnectRequest::set_app(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app();
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpConnectRequest.app)
}
inline void RtmpConnectRequest::set_app(const char* value, size_t size) {
  set_has_app();
  app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpConnectRequest.app)
}
inline ::std::string* RtmpConnectRequest::mutable_app() {
  set_has_app();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.app)
  return app_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpConnectRequest::release_app() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.app)
  if (!has_app()) {
    return NULL;
  }
  clear_has_app();
  return app_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpConnectRequest::set_allocated_app(::std::string* app) {
  if (app != NULL) {
    set_has_app();
  } else {
    clear_has_app();
  }
  app_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.app)
}

// optional string flashVer = 2;
inline bool RtmpConnectRequest::has_flashver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtmpConnectRequest::set_has_flashver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtmpConnectRequest::clear_has_flashver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtmpConnectRequest::clear_flashver() {
  flashver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_flashver();
}
inline const ::std::string& RtmpConnectRequest::flashver() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.flashVer)
  return flashver_.GetNoArena();
}
inline void RtmpConnectRequest::set_flashver(const ::std::string& value) {
  set_has_flashver();
  flashver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.flashVer)
}
#if LANG_CXX11
inline void RtmpConnectRequest::set_flashver(::std::string&& value) {
  set_has_flashver();
  flashver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpConnectRequest.flashVer)
}
#endif
inline void RtmpConnectRequest::set_flashver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_flashver();
  flashver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpConnectRequest.flashVer)
}
inline void RtmpConnectRequest::set_flashver(const char* value, size_t size) {
  set_has_flashver();
  flashver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpConnectRequest.flashVer)
}
inline ::std::string* RtmpConnectRequest::mutable_flashver() {
  set_has_flashver();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.flashVer)
  return flashver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpConnectRequest::release_flashver() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.flashVer)
  if (!has_flashver()) {
    return NULL;
  }
  clear_has_flashver();
  return flashver_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpConnectRequest::set_allocated_flashver(::std::string* flashver) {
  if (flashver != NULL) {
    set_has_flashver();
  } else {
    clear_has_flashver();
  }
  flashver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), flashver);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.flashVer)
}

// optional string swfUrl = 3;
inline bool RtmpConnectRequest::has_swfurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtmpConnectRequest::set_has_swfurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtmpConnectRequest::clear_has_swfurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtmpConnectRequest::clear_swfurl() {
  swfurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_swfurl();
}
inline const ::std::string& RtmpConnectRequest::swfurl() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.swfUrl)
  return swfurl_.GetNoArena();
}
inline void RtmpConnectRequest::set_swfurl(const ::std::string& value) {
  set_has_swfurl();
  swfurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.swfUrl)
}
#if LANG_CXX11
inline void RtmpConnectRequest::set_swfurl(::std::string&& value) {
  set_has_swfurl();
  swfurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpConnectRequest.swfUrl)
}
#endif
inline void RtmpConnectRequest::set_swfurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_swfurl();
  swfurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpConnectRequest.swfUrl)
}
inline void RtmpConnectRequest::set_swfurl(const char* value, size_t size) {
  set_has_swfurl();
  swfurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpConnectRequest.swfUrl)
}
inline ::std::string* RtmpConnectRequest::mutable_swfurl() {
  set_has_swfurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.swfUrl)
  return swfurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpConnectRequest::release_swfurl() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.swfUrl)
  if (!has_swfurl()) {
    return NULL;
  }
  clear_has_swfurl();
  return swfurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpConnectRequest::set_allocated_swfurl(::std::string* swfurl) {
  if (swfurl != NULL) {
    set_has_swfurl();
  } else {
    clear_has_swfurl();
  }
  swfurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), swfurl);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.swfUrl)
}

// optional string tcUrl = 4;
inline bool RtmpConnectRequest::has_tcurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtmpConnectRequest::set_has_tcurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtmpConnectRequest::clear_has_tcurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtmpConnectRequest::clear_tcurl() {
  tcurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tcurl();
}
inline const ::std::string& RtmpConnectRequest::tcurl() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.tcUrl)
  return tcurl_.GetNoArena();
}
inline void RtmpConnectRequest::set_tcurl(const ::std::string& value) {
  set_has_tcurl();
  tcurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.tcUrl)
}
#if LANG_CXX11
inline void RtmpConnectRequest::set_tcurl(::std::string&& value) {
  set_has_tcurl();
  tcurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpConnectRequest.tcUrl)
}
#endif
inline void RtmpConnectRequest::set_tcurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tcurl();
  tcurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpConnectRequest.tcUrl)
}
inline void RtmpConnectRequest::set_tcurl(const char* value, size_t size) {
  set_has_tcurl();
  tcurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpConnectRequest.tcUrl)
}
inline ::std::string* RtmpConnectRequest::mutable_tcurl() {
  set_has_tcurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.tcUrl)
  return tcurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpConnectRequest::release_tcurl() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.tcUrl)
  if (!has_tcurl()) {
    return NULL;
  }
  clear_has_tcurl();
  return tcurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpConnectRequest::set_allocated_tcurl(::std::string* tcurl) {
  if (tcurl != NULL) {
    set_has_tcurl();
  } else {
    clear_has_tcurl();
  }
  tcurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tcurl);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.tcUrl)
}

// optional bool fpad = 5;
inline bool RtmpConnectRequest::has_fpad() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RtmpConnectRequest::set_has_fpad() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RtmpConnectRequest::clear_has_fpad() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RtmpConnectRequest::clear_fpad() {
  fpad_ = false;
  clear_has_fpad();
}
inline bool RtmpConnectRequest::fpad() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.fpad)
  return fpad_;
}
inline void RtmpConnectRequest::set_fpad(bool value) {
  set_has_fpad();
  fpad_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.fpad)
}

// optional double capabilities = 6;
inline bool RtmpConnectRequest::has_capabilities() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RtmpConnectRequest::set_has_capabilities() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RtmpConnectRequest::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RtmpConnectRequest::clear_capabilities() {
  capabilities_ = 0;
  clear_has_capabilities();
}
inline double RtmpConnectRequest::capabilities() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.capabilities)
  return capabilities_;
}
inline void RtmpConnectRequest::set_capabilities(double value) {
  set_has_capabilities();
  capabilities_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.capabilities)
}

// optional double audioCodecs = 7;
inline bool RtmpConnectRequest::has_audiocodecs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RtmpConnectRequest::set_has_audiocodecs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RtmpConnectRequest::clear_has_audiocodecs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RtmpConnectRequest::clear_audiocodecs() {
  audiocodecs_ = 0;
  clear_has_audiocodecs();
}
inline double RtmpConnectRequest::audiocodecs() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.audioCodecs)
  return audiocodecs_;
}
inline void RtmpConnectRequest::set_audiocodecs(double value) {
  set_has_audiocodecs();
  audiocodecs_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.audioCodecs)
}

// optional double videoCodecs = 8;
inline bool RtmpConnectRequest::has_videocodecs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RtmpConnectRequest::set_has_videocodecs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RtmpConnectRequest::clear_has_videocodecs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RtmpConnectRequest::clear_videocodecs() {
  videocodecs_ = 0;
  clear_has_videocodecs();
}
inline double RtmpConnectRequest::videocodecs() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.videoCodecs)
  return videocodecs_;
}
inline void RtmpConnectRequest::set_videocodecs(double value) {
  set_has_videocodecs();
  videocodecs_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.videoCodecs)
}

// optional double videoFunction = 9;
inline bool RtmpConnectRequest::has_videofunction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RtmpConnectRequest::set_has_videofunction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RtmpConnectRequest::clear_has_videofunction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RtmpConnectRequest::clear_videofunction() {
  videofunction_ = 0;
  clear_has_videofunction();
}
inline double RtmpConnectRequest::videofunction() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.videoFunction)
  return videofunction_;
}
inline void RtmpConnectRequest::set_videofunction(double value) {
  set_has_videofunction();
  videofunction_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.videoFunction)
}

// optional string pageUrl = 10;
inline bool RtmpConnectRequest::has_pageurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtmpConnectRequest::set_has_pageurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtmpConnectRequest::clear_has_pageurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtmpConnectRequest::clear_pageurl() {
  pageurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pageurl();
}
inline const ::std::string& RtmpConnectRequest::pageurl() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.pageUrl)
  return pageurl_.GetNoArena();
}
inline void RtmpConnectRequest::set_pageurl(const ::std::string& value) {
  set_has_pageurl();
  pageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.pageUrl)
}
#if LANG_CXX11
inline void RtmpConnectRequest::set_pageurl(::std::string&& value) {
  set_has_pageurl();
  pageurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpConnectRequest.pageUrl)
}
#endif
inline void RtmpConnectRequest::set_pageurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pageurl();
  pageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpConnectRequest.pageUrl)
}
inline void RtmpConnectRequest::set_pageurl(const char* value, size_t size) {
  set_has_pageurl();
  pageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpConnectRequest.pageUrl)
}
inline ::std::string* RtmpConnectRequest::mutable_pageurl() {
  set_has_pageurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.pageUrl)
  return pageurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpConnectRequest::release_pageurl() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.pageUrl)
  if (!has_pageurl()) {
    return NULL;
  }
  clear_has_pageurl();
  return pageurl_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpConnectRequest::set_allocated_pageurl(::std::string* pageurl) {
  if (pageurl != NULL) {
    set_has_pageurl();
  } else {
    clear_has_pageurl();
  }
  pageurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pageurl);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.pageUrl)
}

// optional double objectEncoding = 11;
inline bool RtmpConnectRequest::has_objectencoding() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RtmpConnectRequest::set_has_objectencoding() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RtmpConnectRequest::clear_has_objectencoding() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RtmpConnectRequest::clear_objectencoding() {
  objectencoding_ = 0;
  clear_has_objectencoding();
}
inline double RtmpConnectRequest::objectencoding() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.objectEncoding)
  return objectencoding_;
}
inline void RtmpConnectRequest::set_objectencoding(double value) {
  set_has_objectencoding();
  objectencoding_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.objectEncoding)
}

// optional bool stream_multiplexing = 12;
inline bool RtmpConnectRequest::has_stream_multiplexing() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RtmpConnectRequest::set_has_stream_multiplexing() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RtmpConnectRequest::clear_has_stream_multiplexing() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RtmpConnectRequest::clear_stream_multiplexing() {
  stream_multiplexing_ = false;
  clear_has_stream_multiplexing();
}
inline bool RtmpConnectRequest::stream_multiplexing() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.stream_multiplexing)
  return stream_multiplexing_;
}
inline void RtmpConnectRequest::set_stream_multiplexing(bool value) {
  set_has_stream_multiplexing();
  stream_multiplexing_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.stream_multiplexing)
}

// -------------------------------------------------------------------

// RtmpConnectResponse

// optional string fmsVer = 1;
inline bool RtmpConnectResponse::has_fmsver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtmpConnectResponse::set_has_fmsver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtmpConnectResponse::clear_has_fmsver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtmpConnectResponse::clear_fmsver() {
  fmsver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fmsver();
}
inline const ::std::string& RtmpConnectResponse::fmsver() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.fmsVer)
  return fmsver_.GetNoArena();
}
inline void RtmpConnectResponse::set_fmsver(const ::std::string& value) {
  set_has_fmsver();
  fmsver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.fmsVer)
}
#if LANG_CXX11
inline void RtmpConnectResponse::set_fmsver(::std::string&& value) {
  set_has_fmsver();
  fmsver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpConnectResponse.fmsVer)
}
#endif
inline void RtmpConnectResponse::set_fmsver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fmsver();
  fmsver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpConnectResponse.fmsVer)
}
inline void RtmpConnectResponse::set_fmsver(const char* value, size_t size) {
  set_has_fmsver();
  fmsver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpConnectResponse.fmsVer)
}
inline ::std::string* RtmpConnectResponse::mutable_fmsver() {
  set_has_fmsver();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectResponse.fmsVer)
  return fmsver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpConnectResponse::release_fmsver() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectResponse.fmsVer)
  if (!has_fmsver()) {
    return NULL;
  }
  clear_has_fmsver();
  return fmsver_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpConnectResponse::set_allocated_fmsver(::std::string* fmsver) {
  if (fmsver != NULL) {
    set_has_fmsver();
  } else {
    clear_has_fmsver();
  }
  fmsver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fmsver);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectResponse.fmsVer)
}

// optional double capabilities = 2;
inline bool RtmpConnectResponse::has_capabilities() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtmpConnectResponse::set_has_capabilities() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtmpConnectResponse::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtmpConnectResponse::clear_capabilities() {
  capabilities_ = 0;
  clear_has_capabilities();
}
inline double RtmpConnectResponse::capabilities() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.capabilities)
  return capabilities_;
}
inline void RtmpConnectResponse::set_capabilities(double value) {
  set_has_capabilities();
  capabilities_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.capabilities)
}

// optional double mode = 3;
inline bool RtmpConnectResponse::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtmpConnectResponse::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtmpConnectResponse::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtmpConnectResponse::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline double RtmpConnectResponse::mode() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.mode)
  return mode_;
}
inline void RtmpConnectResponse::set_mode(double value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.mode)
}

// optional bool create_stream_with_play_or_publish = 4;
inline bool RtmpConnectResponse::has_create_stream_with_play_or_publish() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtmpConnectResponse::set_has_create_stream_with_play_or_publish() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtmpConnectResponse::clear_has_create_stream_with_play_or_publish() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtmpConnectResponse::clear_create_stream_with_play_or_publish() {
  create_stream_with_play_or_publish_ = false;
  clear_has_create_stream_with_play_or_publish();
}
inline bool RtmpConnectResponse::create_stream_with_play_or_publish() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.create_stream_with_play_or_publish)
  return create_stream_with_play_or_publish_;
}
inline void RtmpConnectResponse::set_create_stream_with_play_or_publish(bool value) {
  set_has_create_stream_with_play_or_publish();
  create_stream_with_play_or_publish_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.create_stream_with_play_or_publish)
}

// -------------------------------------------------------------------

// RtmpPlay2Options

// optional double len = 1;
inline bool RtmpPlay2Options::has_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtmpPlay2Options::set_has_len() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtmpPlay2Options::clear_has_len() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtmpPlay2Options::clear_len() {
  len_ = 0;
  clear_has_len();
}
inline double RtmpPlay2Options::len() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.len)
  return len_;
}
inline void RtmpPlay2Options::set_len(double value) {
  set_has_len();
  len_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.len)
}

// optional double offset = 2;
inline bool RtmpPlay2Options::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtmpPlay2Options::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtmpPlay2Options::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtmpPlay2Options::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline double RtmpPlay2Options::offset() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.offset)
  return offset_;
}
inline void RtmpPlay2Options::set_offset(double value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.offset)
}

// optional string oldStreamName = 3;
inline bool RtmpPlay2Options::has_oldstreamname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtmpPlay2Options::set_has_oldstreamname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtmpPlay2Options::clear_has_oldstreamname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtmpPlay2Options::clear_oldstreamname() {
  oldstreamname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oldstreamname();
}
inline const ::std::string& RtmpPlay2Options::oldstreamname() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.oldStreamName)
  return oldstreamname_.GetNoArena();
}
inline void RtmpPlay2Options::set_oldstreamname(const ::std::string& value) {
  set_has_oldstreamname();
  oldstreamname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.oldStreamName)
}
#if LANG_CXX11
inline void RtmpPlay2Options::set_oldstreamname(::std::string&& value) {
  set_has_oldstreamname();
  oldstreamname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpPlay2Options.oldStreamName)
}
#endif
inline void RtmpPlay2Options::set_oldstreamname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oldstreamname();
  oldstreamname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpPlay2Options.oldStreamName)
}
inline void RtmpPlay2Options::set_oldstreamname(const char* value, size_t size) {
  set_has_oldstreamname();
  oldstreamname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpPlay2Options.oldStreamName)
}
inline ::std::string* RtmpPlay2Options::mutable_oldstreamname() {
  set_has_oldstreamname();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.oldStreamName)
  return oldstreamname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpPlay2Options::release_oldstreamname() {
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.oldStreamName)
  if (!has_oldstreamname()) {
    return NULL;
  }
  clear_has_oldstreamname();
  return oldstreamname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpPlay2Options::set_allocated_oldstreamname(::std::string* oldstreamname) {
  if (oldstreamname != NULL) {
    set_has_oldstreamname();
  } else {
    clear_has_oldstreamname();
  }
  oldstreamname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oldstreamname);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.oldStreamName)
}

// optional double start = 4;
inline bool RtmpPlay2Options::has_start() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RtmpPlay2Options::set_has_start() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RtmpPlay2Options::clear_has_start() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RtmpPlay2Options::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline double RtmpPlay2Options::start() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.start)
  return start_;
}
inline void RtmpPlay2Options::set_start(double value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.start)
}

// optional string streamName = 5;
inline bool RtmpPlay2Options::has_streamname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtmpPlay2Options::set_has_streamname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtmpPlay2Options::clear_has_streamname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtmpPlay2Options::clear_streamname() {
  streamname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_streamname();
}
inline const ::std::string& RtmpPlay2Options::streamname() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.streamName)
  return streamname_.GetNoArena();
}
inline void RtmpPlay2Options::set_streamname(const ::std::string& value) {
  set_has_streamname();
  streamname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.streamName)
}
#if LANG_CXX11
inline void RtmpPlay2Options::set_streamname(::std::string&& value) {
  set_has_streamname();
  streamname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpPlay2Options.streamName)
}
#endif
inline void RtmpPlay2Options::set_streamname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_streamname();
  streamname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpPlay2Options.streamName)
}
inline void RtmpPlay2Options::set_streamname(const char* value, size_t size) {
  set_has_streamname();
  streamname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpPlay2Options.streamName)
}
inline ::std::string* RtmpPlay2Options::mutable_streamname() {
  set_has_streamname();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.streamName)
  return streamname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpPlay2Options::release_streamname() {
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.streamName)
  if (!has_streamname()) {
    return NULL;
  }
  clear_has_streamname();
  return streamname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpPlay2Options::set_allocated_streamname(::std::string* streamname) {
  if (streamname != NULL) {
    set_has_streamname();
  } else {
    clear_has_streamname();
  }
  streamname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), streamname);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.streamName)
}

// optional string transition = 6;
inline bool RtmpPlay2Options::has_transition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtmpPlay2Options::set_has_transition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtmpPlay2Options::clear_has_transition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtmpPlay2Options::clear_transition() {
  transition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transition();
}
inline const ::std::string& RtmpPlay2Options::transition() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.transition)
  return transition_.GetNoArena();
}
inline void RtmpPlay2Options::set_transition(const ::std::string& value) {
  set_has_transition();
  transition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.transition)
}
#if LANG_CXX11
inline void RtmpPlay2Options::set_transition(::std::string&& value) {
  set_has_transition();
  transition_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpPlay2Options.transition)
}
#endif
inline void RtmpPlay2Options::set_transition(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_transition();
  transition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpPlay2Options.transition)
}
inline void RtmpPlay2Options::set_transition(const char* value, size_t size) {
  set_has_transition();
  transition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpPlay2Options.transition)
}
inline ::std::string* RtmpPlay2Options::mutable_transition() {
  set_has_transition();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.transition)
  return transition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpPlay2Options::release_transition() {
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.transition)
  if (!has_transition()) {
    return NULL;
  }
  clear_has_transition();
  return transition_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpPlay2Options::set_allocated_transition(::std::string* transition) {
  if (transition != NULL) {
    set_has_transition();
  } else {
    clear_has_transition();
  }
  transition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transition);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.transition)
}

// -------------------------------------------------------------------

// RtmpInfo

// optional string code = 1;
inline bool RtmpInfo::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtmpInfo::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtmpInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtmpInfo::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code();
}
inline const ::std::string& RtmpInfo::code() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.code)
  return code_.GetNoArena();
}
inline void RtmpInfo::set_code(const ::std::string& value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.code)
}
#if LANG_CXX11
inline void RtmpInfo::set_code(::std::string&& value) {
  set_has_code();
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpInfo.code)
}
#endif
inline void RtmpInfo::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpInfo.code)
}
inline void RtmpInfo::set_code(const char* value, size_t size) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpInfo.code)
}
inline ::std::string* RtmpInfo::mutable_code() {
  set_has_code();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpInfo::release_code() {
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.code)
  if (!has_code()) {
    return NULL;
  }
  clear_has_code();
  return code_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpInfo::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    set_has_code();
  } else {
    clear_has_code();
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.code)
}

// optional string level = 2;
inline bool RtmpInfo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtmpInfo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtmpInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtmpInfo::clear_level() {
  level_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_level();
}
inline const ::std::string& RtmpInfo::level() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.level)
  return level_.GetNoArena();
}
inline void RtmpInfo::set_level(const ::std::string& value) {
  set_has_level();
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.level)
}
#if LANG_CXX11
inline void RtmpInfo::set_level(::std::string&& value) {
  set_has_level();
  level_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpInfo.level)
}
#endif
inline void RtmpInfo::set_level(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_level();
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpInfo.level)
}
inline void RtmpInfo::set_level(const char* value, size_t size) {
  set_has_level();
  level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpInfo.level)
}
inline ::std::string* RtmpInfo::mutable_level() {
  set_has_level();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.level)
  return level_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpInfo::release_level() {
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.level)
  if (!has_level()) {
    return NULL;
  }
  clear_has_level();
  return level_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpInfo::set_allocated_level(::std::string* level) {
  if (level != NULL) {
    set_has_level();
  } else {
    clear_has_level();
  }
  level_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), level);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.level)
}

// optional string description = 3;
inline bool RtmpInfo::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtmpInfo::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtmpInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtmpInfo::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& RtmpInfo::description() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.description)
  return description_.GetNoArena();
}
inline void RtmpInfo::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.description)
}
#if LANG_CXX11
inline void RtmpInfo::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:brpc.RtmpInfo.description)
}
#endif
inline void RtmpInfo::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:brpc.RtmpInfo.description)
}
inline void RtmpInfo::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:brpc.RtmpInfo.description)
}
inline ::std::string* RtmpInfo::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RtmpInfo::release_description() {
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RtmpInfo::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.description)
}

// optional double objectEncoding = 4;
inline bool RtmpInfo::has_objectencoding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtmpInfo::set_has_objectencoding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtmpInfo::clear_has_objectencoding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtmpInfo::clear_objectencoding() {
  objectencoding_ = 0;
  clear_has_objectencoding();
}
inline double RtmpInfo::objectencoding() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.objectEncoding)
  return objectencoding_;
}
inline void RtmpInfo::set_objectencoding(double value) {
  set_has_objectencoding();
  objectencoding_ = value;
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.objectEncoding)
}

// -------------------------------------------------------------------

// RtmpEmptyObject

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace brpc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_brpc_2frtmp_2eproto
