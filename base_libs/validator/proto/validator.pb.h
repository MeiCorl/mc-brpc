// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: validator.proto

#ifndef PROTOBUF_INCLUDED_validator_2eproto
#define PROTOBUF_INCLUDED_validator_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_validator_2eproto 

namespace protobuf_validator_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_validator_2eproto
namespace validator {
class ArrayRule;
class ArrayRuleDefaultTypeInternal;
extern ArrayRuleDefaultTypeInternal _ArrayRule_default_instance_;
class DoubleRule;
class DoubleRuleDefaultTypeInternal;
extern DoubleRuleDefaultTypeInternal _DoubleRule_default_instance_;
class EnumRule;
class EnumRuleDefaultTypeInternal;
extern EnumRuleDefaultTypeInternal _EnumRule_default_instance_;
class FloatRule;
class FloatRuleDefaultTypeInternal;
extern FloatRuleDefaultTypeInternal _FloatRule_default_instance_;
class Int32Rule;
class Int32RuleDefaultTypeInternal;
extern Int32RuleDefaultTypeInternal _Int32Rule_default_instance_;
class Int64Rule;
class Int64RuleDefaultTypeInternal;
extern Int64RuleDefaultTypeInternal _Int64Rule_default_instance_;
class StringRule;
class StringRuleDefaultTypeInternal;
extern StringRuleDefaultTypeInternal _StringRule_default_instance_;
class UInt32Rule;
class UInt32RuleDefaultTypeInternal;
extern UInt32RuleDefaultTypeInternal _UInt32Rule_default_instance_;
class UInt64Rule;
class UInt64RuleDefaultTypeInternal;
extern UInt64RuleDefaultTypeInternal _UInt64Rule_default_instance_;
class ValidateRules;
class ValidateRulesDefaultTypeInternal;
extern ValidateRulesDefaultTypeInternal _ValidateRules_default_instance_;
}  // namespace validator
namespace google {
namespace protobuf {
template<> ::validator::ArrayRule* Arena::CreateMaybeMessage<::validator::ArrayRule>(Arena*);
template<> ::validator::DoubleRule* Arena::CreateMaybeMessage<::validator::DoubleRule>(Arena*);
template<> ::validator::EnumRule* Arena::CreateMaybeMessage<::validator::EnumRule>(Arena*);
template<> ::validator::FloatRule* Arena::CreateMaybeMessage<::validator::FloatRule>(Arena*);
template<> ::validator::Int32Rule* Arena::CreateMaybeMessage<::validator::Int32Rule>(Arena*);
template<> ::validator::Int64Rule* Arena::CreateMaybeMessage<::validator::Int64Rule>(Arena*);
template<> ::validator::StringRule* Arena::CreateMaybeMessage<::validator::StringRule>(Arena*);
template<> ::validator::UInt32Rule* Arena::CreateMaybeMessage<::validator::UInt32Rule>(Arena*);
template<> ::validator::UInt64Rule* Arena::CreateMaybeMessage<::validator::UInt64Rule>(Arena*);
template<> ::validator::ValidateRules* Arena::CreateMaybeMessage<::validator::ValidateRules>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace validator {

// ===================================================================

class Int32Rule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.Int32Rule) */ {
 public:
  Int32Rule();
  virtual ~Int32Rule();

  Int32Rule(const Int32Rule& from);

  inline Int32Rule& operator=(const Int32Rule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int32Rule(Int32Rule&& from) noexcept
    : Int32Rule() {
    *this = ::std::move(from);
  }

  inline Int32Rule& operator=(Int32Rule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Int32Rule& default_instance();

  enum LtRuleCase {
    kLt = 1,
    LT_RULE_NOT_SET = 0,
  };

  enum LteRuleCase {
    kLte = 2,
    LTE_RULE_NOT_SET = 0,
  };

  enum GtRuleCase {
    kGt = 3,
    GT_RULE_NOT_SET = 0,
  };

  enum GteRuleCase {
    kGte = 4,
    GTE_RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int32Rule* internal_default_instance() {
    return reinterpret_cast<const Int32Rule*>(
               &_Int32Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Int32Rule* other);
  friend void swap(Int32Rule& a, Int32Rule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int32Rule* New() const final {
    return CreateMaybeMessage<Int32Rule>(NULL);
  }

  Int32Rule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int32Rule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int32Rule& from);
  void MergeFrom(const Int32Rule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32Rule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 in = 5;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 5;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // repeated int32 not_in = 6;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 6;
  ::google::protobuf::int32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int32 value);
  void add_not_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_not_in();

  // int32 lt = 1;
  private:
  bool has_lt() const;
  public:
  void clear_lt();
  static const int kLtFieldNumber = 1;
  ::google::protobuf::int32 lt() const;
  void set_lt(::google::protobuf::int32 value);

  // int32 lte = 2;
  private:
  bool has_lte() const;
  public:
  void clear_lte();
  static const int kLteFieldNumber = 2;
  ::google::protobuf::int32 lte() const;
  void set_lte(::google::protobuf::int32 value);

  // int32 gt = 3;
  private:
  bool has_gt() const;
  public:
  void clear_gt();
  static const int kGtFieldNumber = 3;
  ::google::protobuf::int32 gt() const;
  void set_gt(::google::protobuf::int32 value);

  // int32 gte = 4;
  private:
  bool has_gte() const;
  public:
  void clear_gte();
  static const int kGteFieldNumber = 4;
  ::google::protobuf::int32 gte() const;
  void set_gte(::google::protobuf::int32 value);

  void clear_lt_rule();
  LtRuleCase lt_rule_case() const;
  void clear_lte_rule();
  LteRuleCase lte_rule_case() const;
  void clear_gt_rule();
  GtRuleCase gt_rule_case() const;
  void clear_gte_rule();
  GteRuleCase gte_rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.Int32Rule)
 private:
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_lt_rule() const;
  inline void clear_has_lt_rule();

  inline bool has_lte_rule() const;
  inline void clear_has_lte_rule();

  inline bool has_gt_rule() const;
  inline void clear_has_gt_rule();

  inline bool has_gte_rule() const;
  inline void clear_has_gte_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  mutable int _in_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > not_in_;
  mutable int _not_in_cached_byte_size_;
  union LtRuleUnion {
    LtRuleUnion() {}
    ::google::protobuf::int32 lt_;
  } lt_rule_;
  union LteRuleUnion {
    LteRuleUnion() {}
    ::google::protobuf::int32 lte_;
  } lte_rule_;
  union GtRuleUnion {
    GtRuleUnion() {}
    ::google::protobuf::int32 gt_;
  } gt_rule_;
  union GteRuleUnion {
    GteRuleUnion() {}
    ::google::protobuf::int32 gte_;
  } gte_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int64Rule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.Int64Rule) */ {
 public:
  Int64Rule();
  virtual ~Int64Rule();

  Int64Rule(const Int64Rule& from);

  inline Int64Rule& operator=(const Int64Rule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int64Rule(Int64Rule&& from) noexcept
    : Int64Rule() {
    *this = ::std::move(from);
  }

  inline Int64Rule& operator=(Int64Rule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Int64Rule& default_instance();

  enum LtRuleCase {
    kLt = 1,
    LT_RULE_NOT_SET = 0,
  };

  enum LteRuleCase {
    kLte = 2,
    LTE_RULE_NOT_SET = 0,
  };

  enum GtRuleCase {
    kGt = 3,
    GT_RULE_NOT_SET = 0,
  };

  enum GteRuleCase {
    kGte = 4,
    GTE_RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int64Rule* internal_default_instance() {
    return reinterpret_cast<const Int64Rule*>(
               &_Int64Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Int64Rule* other);
  friend void swap(Int64Rule& a, Int64Rule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int64Rule* New() const final {
    return CreateMaybeMessage<Int64Rule>(NULL);
  }

  Int64Rule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int64Rule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int64Rule& from);
  void MergeFrom(const Int64Rule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64Rule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 in = 5;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 5;
  ::google::protobuf::int64 in(int index) const;
  void set_in(int index, ::google::protobuf::int64 value);
  void add_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_in();

  // repeated int64 not_in = 6;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 6;
  ::google::protobuf::int64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::int64 value);
  void add_not_in(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_not_in();

  // int64 lt = 1;
  private:
  bool has_lt() const;
  public:
  void clear_lt();
  static const int kLtFieldNumber = 1;
  ::google::protobuf::int64 lt() const;
  void set_lt(::google::protobuf::int64 value);

  // int64 lte = 2;
  private:
  bool has_lte() const;
  public:
  void clear_lte();
  static const int kLteFieldNumber = 2;
  ::google::protobuf::int64 lte() const;
  void set_lte(::google::protobuf::int64 value);

  // int64 gt = 3;
  private:
  bool has_gt() const;
  public:
  void clear_gt();
  static const int kGtFieldNumber = 3;
  ::google::protobuf::int64 gt() const;
  void set_gt(::google::protobuf::int64 value);

  // int64 gte = 4;
  private:
  bool has_gte() const;
  public:
  void clear_gte();
  static const int kGteFieldNumber = 4;
  ::google::protobuf::int64 gte() const;
  void set_gte(::google::protobuf::int64 value);

  void clear_lt_rule();
  LtRuleCase lt_rule_case() const;
  void clear_lte_rule();
  LteRuleCase lte_rule_case() const;
  void clear_gt_rule();
  GtRuleCase gt_rule_case() const;
  void clear_gte_rule();
  GteRuleCase gte_rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.Int64Rule)
 private:
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_lt_rule() const;
  inline void clear_has_lt_rule();

  inline bool has_lte_rule() const;
  inline void clear_has_lte_rule();

  inline bool has_gt_rule() const;
  inline void clear_has_gt_rule();

  inline bool has_gte_rule() const;
  inline void clear_has_gte_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > in_;
  mutable int _in_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > not_in_;
  mutable int _not_in_cached_byte_size_;
  union LtRuleUnion {
    LtRuleUnion() {}
    ::google::protobuf::int64 lt_;
  } lt_rule_;
  union LteRuleUnion {
    LteRuleUnion() {}
    ::google::protobuf::int64 lte_;
  } lte_rule_;
  union GtRuleUnion {
    GtRuleUnion() {}
    ::google::protobuf::int64 gt_;
  } gt_rule_;
  union GteRuleUnion {
    GteRuleUnion() {}
    ::google::protobuf::int64 gte_;
  } gte_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UInt32Rule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.UInt32Rule) */ {
 public:
  UInt32Rule();
  virtual ~UInt32Rule();

  UInt32Rule(const UInt32Rule& from);

  inline UInt32Rule& operator=(const UInt32Rule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt32Rule(UInt32Rule&& from) noexcept
    : UInt32Rule() {
    *this = ::std::move(from);
  }

  inline UInt32Rule& operator=(UInt32Rule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UInt32Rule& default_instance();

  enum LtRuleCase {
    kLt = 1,
    LT_RULE_NOT_SET = 0,
  };

  enum LteRuleCase {
    kLte = 2,
    LTE_RULE_NOT_SET = 0,
  };

  enum GtRuleCase {
    kGt = 3,
    GT_RULE_NOT_SET = 0,
  };

  enum GteRuleCase {
    kGte = 4,
    GTE_RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UInt32Rule* internal_default_instance() {
    return reinterpret_cast<const UInt32Rule*>(
               &_UInt32Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UInt32Rule* other);
  friend void swap(UInt32Rule& a, UInt32Rule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt32Rule* New() const final {
    return CreateMaybeMessage<UInt32Rule>(NULL);
  }

  UInt32Rule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UInt32Rule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UInt32Rule& from);
  void MergeFrom(const UInt32Rule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInt32Rule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 in = 5;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 5;
  ::google::protobuf::uint32 in(int index) const;
  void set_in(int index, ::google::protobuf::uint32 value);
  void add_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_in();

  // repeated uint32 not_in = 6;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 6;
  ::google::protobuf::uint32 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint32 value);
  void add_not_in(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_not_in();

  // uint32 lt = 1;
  private:
  bool has_lt() const;
  public:
  void clear_lt();
  static const int kLtFieldNumber = 1;
  ::google::protobuf::uint32 lt() const;
  void set_lt(::google::protobuf::uint32 value);

  // uint32 lte = 2;
  private:
  bool has_lte() const;
  public:
  void clear_lte();
  static const int kLteFieldNumber = 2;
  ::google::protobuf::uint32 lte() const;
  void set_lte(::google::protobuf::uint32 value);

  // uint32 gt = 3;
  private:
  bool has_gt() const;
  public:
  void clear_gt();
  static const int kGtFieldNumber = 3;
  ::google::protobuf::uint32 gt() const;
  void set_gt(::google::protobuf::uint32 value);

  // uint32 gte = 4;
  private:
  bool has_gte() const;
  public:
  void clear_gte();
  static const int kGteFieldNumber = 4;
  ::google::protobuf::uint32 gte() const;
  void set_gte(::google::protobuf::uint32 value);

  void clear_lt_rule();
  LtRuleCase lt_rule_case() const;
  void clear_lte_rule();
  LteRuleCase lte_rule_case() const;
  void clear_gt_rule();
  GtRuleCase gt_rule_case() const;
  void clear_gte_rule();
  GteRuleCase gte_rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.UInt32Rule)
 private:
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_lt_rule() const;
  inline void clear_has_lt_rule();

  inline bool has_lte_rule() const;
  inline void clear_has_lte_rule();

  inline bool has_gt_rule() const;
  inline void clear_has_gt_rule();

  inline bool has_gte_rule() const;
  inline void clear_has_gte_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > in_;
  mutable int _in_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > not_in_;
  mutable int _not_in_cached_byte_size_;
  union LtRuleUnion {
    LtRuleUnion() {}
    ::google::protobuf::uint32 lt_;
  } lt_rule_;
  union LteRuleUnion {
    LteRuleUnion() {}
    ::google::protobuf::uint32 lte_;
  } lte_rule_;
  union GtRuleUnion {
    GtRuleUnion() {}
    ::google::protobuf::uint32 gt_;
  } gt_rule_;
  union GteRuleUnion {
    GteRuleUnion() {}
    ::google::protobuf::uint32 gte_;
  } gte_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UInt64Rule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.UInt64Rule) */ {
 public:
  UInt64Rule();
  virtual ~UInt64Rule();

  UInt64Rule(const UInt64Rule& from);

  inline UInt64Rule& operator=(const UInt64Rule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt64Rule(UInt64Rule&& from) noexcept
    : UInt64Rule() {
    *this = ::std::move(from);
  }

  inline UInt64Rule& operator=(UInt64Rule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UInt64Rule& default_instance();

  enum LtRuleCase {
    kLt = 1,
    LT_RULE_NOT_SET = 0,
  };

  enum LteRuleCase {
    kLte = 2,
    LTE_RULE_NOT_SET = 0,
  };

  enum GtRuleCase {
    kGt = 3,
    GT_RULE_NOT_SET = 0,
  };

  enum GteRuleCase {
    kGte = 4,
    GTE_RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UInt64Rule* internal_default_instance() {
    return reinterpret_cast<const UInt64Rule*>(
               &_UInt64Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(UInt64Rule* other);
  friend void swap(UInt64Rule& a, UInt64Rule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt64Rule* New() const final {
    return CreateMaybeMessage<UInt64Rule>(NULL);
  }

  UInt64Rule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UInt64Rule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UInt64Rule& from);
  void MergeFrom(const UInt64Rule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInt64Rule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 in = 5;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 5;
  ::google::protobuf::uint64 in(int index) const;
  void set_in(int index, ::google::protobuf::uint64 value);
  void add_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_in();

  // repeated uint64 not_in = 6;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 6;
  ::google::protobuf::uint64 not_in(int index) const;
  void set_not_in(int index, ::google::protobuf::uint64 value);
  void add_not_in(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      not_in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_not_in();

  // uint64 lt = 1;
  private:
  bool has_lt() const;
  public:
  void clear_lt();
  static const int kLtFieldNumber = 1;
  ::google::protobuf::uint64 lt() const;
  void set_lt(::google::protobuf::uint64 value);

  // uint64 lte = 2;
  private:
  bool has_lte() const;
  public:
  void clear_lte();
  static const int kLteFieldNumber = 2;
  ::google::protobuf::uint64 lte() const;
  void set_lte(::google::protobuf::uint64 value);

  // uint64 gt = 3;
  private:
  bool has_gt() const;
  public:
  void clear_gt();
  static const int kGtFieldNumber = 3;
  ::google::protobuf::uint64 gt() const;
  void set_gt(::google::protobuf::uint64 value);

  // uint64 gte = 4;
  private:
  bool has_gte() const;
  public:
  void clear_gte();
  static const int kGteFieldNumber = 4;
  ::google::protobuf::uint64 gte() const;
  void set_gte(::google::protobuf::uint64 value);

  void clear_lt_rule();
  LtRuleCase lt_rule_case() const;
  void clear_lte_rule();
  LteRuleCase lte_rule_case() const;
  void clear_gt_rule();
  GtRuleCase gt_rule_case() const;
  void clear_gte_rule();
  GteRuleCase gte_rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.UInt64Rule)
 private:
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_lt_rule() const;
  inline void clear_has_lt_rule();

  inline bool has_lte_rule() const;
  inline void clear_has_lte_rule();

  inline bool has_gt_rule() const;
  inline void clear_has_gt_rule();

  inline bool has_gte_rule() const;
  inline void clear_has_gte_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > in_;
  mutable int _in_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > not_in_;
  mutable int _not_in_cached_byte_size_;
  union LtRuleUnion {
    LtRuleUnion() {}
    ::google::protobuf::uint64 lt_;
  } lt_rule_;
  union LteRuleUnion {
    LteRuleUnion() {}
    ::google::protobuf::uint64 lte_;
  } lte_rule_;
  union GtRuleUnion {
    GtRuleUnion() {}
    ::google::protobuf::uint64 gt_;
  } gt_rule_;
  union GteRuleUnion {
    GteRuleUnion() {}
    ::google::protobuf::uint64 gte_;
  } gte_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FloatRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.FloatRule) */ {
 public:
  FloatRule();
  virtual ~FloatRule();

  FloatRule(const FloatRule& from);

  inline FloatRule& operator=(const FloatRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatRule(FloatRule&& from) noexcept
    : FloatRule() {
    *this = ::std::move(from);
  }

  inline FloatRule& operator=(FloatRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatRule& default_instance();

  enum LtRuleCase {
    kLt = 1,
    LT_RULE_NOT_SET = 0,
  };

  enum LteRuleCase {
    kLte = 2,
    LTE_RULE_NOT_SET = 0,
  };

  enum GtRuleCase {
    kGt = 3,
    GT_RULE_NOT_SET = 0,
  };

  enum GteRuleCase {
    kGte = 4,
    GTE_RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatRule* internal_default_instance() {
    return reinterpret_cast<const FloatRule*>(
               &_FloatRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FloatRule* other);
  friend void swap(FloatRule& a, FloatRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatRule* New() const final {
    return CreateMaybeMessage<FloatRule>(NULL);
  }

  FloatRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatRule& from);
  void MergeFrom(const FloatRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float in = 5;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 5;
  float in(int index) const;
  void set_in(int index, float value);
  void add_in(float value);
  const ::google::protobuf::RepeatedField< float >&
      in() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_in();

  // repeated float not_in = 6;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 6;
  float not_in(int index) const;
  void set_not_in(int index, float value);
  void add_not_in(float value);
  const ::google::protobuf::RepeatedField< float >&
      not_in() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_not_in();

  // float lt = 1;
  private:
  bool has_lt() const;
  public:
  void clear_lt();
  static const int kLtFieldNumber = 1;
  float lt() const;
  void set_lt(float value);

  // float lte = 2;
  private:
  bool has_lte() const;
  public:
  void clear_lte();
  static const int kLteFieldNumber = 2;
  float lte() const;
  void set_lte(float value);

  // float gt = 3;
  private:
  bool has_gt() const;
  public:
  void clear_gt();
  static const int kGtFieldNumber = 3;
  float gt() const;
  void set_gt(float value);

  // float gte = 4;
  private:
  bool has_gte() const;
  public:
  void clear_gte();
  static const int kGteFieldNumber = 4;
  float gte() const;
  void set_gte(float value);

  void clear_lt_rule();
  LtRuleCase lt_rule_case() const;
  void clear_lte_rule();
  LteRuleCase lte_rule_case() const;
  void clear_gt_rule();
  GtRuleCase gt_rule_case() const;
  void clear_gte_rule();
  GteRuleCase gte_rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.FloatRule)
 private:
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_lt_rule() const;
  inline void clear_has_lt_rule();

  inline bool has_lte_rule() const;
  inline void clear_has_lte_rule();

  inline bool has_gt_rule() const;
  inline void clear_has_gt_rule();

  inline bool has_gte_rule() const;
  inline void clear_has_gte_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > in_;
  mutable int _in_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > not_in_;
  mutable int _not_in_cached_byte_size_;
  union LtRuleUnion {
    LtRuleUnion() {}
    float lt_;
  } lt_rule_;
  union LteRuleUnion {
    LteRuleUnion() {}
    float lte_;
  } lte_rule_;
  union GtRuleUnion {
    GtRuleUnion() {}
    float gt_;
  } gt_rule_;
  union GteRuleUnion {
    GteRuleUnion() {}
    float gte_;
  } gte_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoubleRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.DoubleRule) */ {
 public:
  DoubleRule();
  virtual ~DoubleRule();

  DoubleRule(const DoubleRule& from);

  inline DoubleRule& operator=(const DoubleRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleRule(DoubleRule&& from) noexcept
    : DoubleRule() {
    *this = ::std::move(from);
  }

  inline DoubleRule& operator=(DoubleRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleRule& default_instance();

  enum LtRuleCase {
    kLt = 1,
    LT_RULE_NOT_SET = 0,
  };

  enum LteRuleCase {
    kLte = 2,
    LTE_RULE_NOT_SET = 0,
  };

  enum GtRuleCase {
    kGt = 3,
    GT_RULE_NOT_SET = 0,
  };

  enum GteRuleCase {
    kGte = 4,
    GTE_RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleRule* internal_default_instance() {
    return reinterpret_cast<const DoubleRule*>(
               &_DoubleRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DoubleRule* other);
  friend void swap(DoubleRule& a, DoubleRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleRule* New() const final {
    return CreateMaybeMessage<DoubleRule>(NULL);
  }

  DoubleRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoubleRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoubleRule& from);
  void MergeFrom(const DoubleRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double in = 5;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 5;
  double in(int index) const;
  void set_in(int index, double value);
  void add_in(double value);
  const ::google::protobuf::RepeatedField< double >&
      in() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_in();

  // repeated double not_in = 6;
  int not_in_size() const;
  void clear_not_in();
  static const int kNotInFieldNumber = 6;
  double not_in(int index) const;
  void set_not_in(int index, double value);
  void add_not_in(double value);
  const ::google::protobuf::RepeatedField< double >&
      not_in() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_not_in();

  // double lt = 1;
  private:
  bool has_lt() const;
  public:
  void clear_lt();
  static const int kLtFieldNumber = 1;
  double lt() const;
  void set_lt(double value);

  // double lte = 2;
  private:
  bool has_lte() const;
  public:
  void clear_lte();
  static const int kLteFieldNumber = 2;
  double lte() const;
  void set_lte(double value);

  // double gt = 3;
  private:
  bool has_gt() const;
  public:
  void clear_gt();
  static const int kGtFieldNumber = 3;
  double gt() const;
  void set_gt(double value);

  // double gte = 4;
  private:
  bool has_gte() const;
  public:
  void clear_gte();
  static const int kGteFieldNumber = 4;
  double gte() const;
  void set_gte(double value);

  void clear_lt_rule();
  LtRuleCase lt_rule_case() const;
  void clear_lte_rule();
  LteRuleCase lte_rule_case() const;
  void clear_gt_rule();
  GtRuleCase gt_rule_case() const;
  void clear_gte_rule();
  GteRuleCase gte_rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.DoubleRule)
 private:
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_lt_rule() const;
  inline void clear_has_lt_rule();

  inline bool has_lte_rule() const;
  inline void clear_has_lte_rule();

  inline bool has_gt_rule() const;
  inline void clear_has_gt_rule();

  inline bool has_gte_rule() const;
  inline void clear_has_gte_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > in_;
  mutable int _in_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > not_in_;
  mutable int _not_in_cached_byte_size_;
  union LtRuleUnion {
    LtRuleUnion() {}
    double lt_;
  } lt_rule_;
  union LteRuleUnion {
    LteRuleUnion() {}
    double lte_;
  } lte_rule_;
  union GtRuleUnion {
    GtRuleUnion() {}
    double gt_;
  } gt_rule_;
  union GteRuleUnion {
    GteRuleUnion() {}
    double gte_;
  } gte_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[4];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.StringRule) */ {
 public:
  StringRule();
  virtual ~StringRule();

  StringRule(const StringRule& from);

  inline StringRule& operator=(const StringRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringRule(StringRule&& from) noexcept
    : StringRule() {
    *this = ::std::move(from);
  }

  inline StringRule& operator=(StringRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringRule& default_instance();

  enum MinLenRuleCase {
    kMinLen = 2,
    MIN_LEN_RULE_NOT_SET = 0,
  };

  enum MaxLenRuleCase {
    kMaxLen = 3,
    MAX_LEN_RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringRule* internal_default_instance() {
    return reinterpret_cast<const StringRule*>(
               &_StringRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(StringRule* other);
  friend void swap(StringRule& a, StringRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringRule* New() const final {
    return CreateMaybeMessage<StringRule>(NULL);
  }

  StringRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringRule& from);
  void MergeFrom(const StringRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string regex_pattern = 4;
  void clear_regex_pattern();
  static const int kRegexPatternFieldNumber = 4;
  const ::std::string& regex_pattern() const;
  void set_regex_pattern(const ::std::string& value);
  #if LANG_CXX11
  void set_regex_pattern(::std::string&& value);
  #endif
  void set_regex_pattern(const char* value);
  void set_regex_pattern(const char* value, size_t size);
  ::std::string* mutable_regex_pattern();
  ::std::string* release_regex_pattern();
  void set_allocated_regex_pattern(::std::string* regex_pattern);

  // bool not_empty = 1;
  void clear_not_empty();
  static const int kNotEmptyFieldNumber = 1;
  bool not_empty() const;
  void set_not_empty(bool value);

  // uint32 min_len = 2;
  private:
  bool has_min_len() const;
  public:
  void clear_min_len();
  static const int kMinLenFieldNumber = 2;
  ::google::protobuf::uint32 min_len() const;
  void set_min_len(::google::protobuf::uint32 value);

  // uint32 max_len = 3;
  private:
  bool has_max_len() const;
  public:
  void clear_max_len();
  static const int kMaxLenFieldNumber = 3;
  ::google::protobuf::uint32 max_len() const;
  void set_max_len(::google::protobuf::uint32 value);

  void clear_min_len_rule();
  MinLenRuleCase min_len_rule_case() const;
  void clear_max_len_rule();
  MaxLenRuleCase max_len_rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.StringRule)
 private:
  void set_has_min_len();
  void set_has_max_len();

  inline bool has_min_len_rule() const;
  inline void clear_has_min_len_rule();

  inline bool has_max_len_rule() const;
  inline void clear_has_max_len_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr regex_pattern_;
  bool not_empty_;
  union MinLenRuleUnion {
    MinLenRuleUnion() {}
    ::google::protobuf::uint32 min_len_;
  } min_len_rule_;
  union MaxLenRuleUnion {
    MaxLenRuleUnion() {}
    ::google::protobuf::uint32 max_len_;
  } max_len_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnumRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.EnumRule) */ {
 public:
  EnumRule();
  virtual ~EnumRule();

  EnumRule(const EnumRule& from);

  inline EnumRule& operator=(const EnumRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnumRule(EnumRule&& from) noexcept
    : EnumRule() {
    *this = ::std::move(from);
  }

  inline EnumRule& operator=(EnumRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnumRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnumRule* internal_default_instance() {
    return reinterpret_cast<const EnumRule*>(
               &_EnumRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(EnumRule* other);
  friend void swap(EnumRule& a, EnumRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnumRule* New() const final {
    return CreateMaybeMessage<EnumRule>(NULL);
  }

  EnumRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnumRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnumRule& from);
  void MergeFrom(const EnumRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 in = 1;
  int in_size() const;
  void clear_in();
  static const int kInFieldNumber = 1;
  ::google::protobuf::int32 in(int index) const;
  void set_in(int index, ::google::protobuf::int32 value);
  void add_in(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      in() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_in();

  // @@protoc_insertion_point(class_scope:validator.EnumRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > in_;
  mutable int _in_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArrayRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.ArrayRule) */ {
 public:
  ArrayRule();
  virtual ~ArrayRule();

  ArrayRule(const ArrayRule& from);

  inline ArrayRule& operator=(const ArrayRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArrayRule(ArrayRule&& from) noexcept
    : ArrayRule() {
    *this = ::std::move(from);
  }

  inline ArrayRule& operator=(ArrayRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArrayRule& default_instance();

  enum MinLenRuleCase {
    kMinLen = 2,
    MIN_LEN_RULE_NOT_SET = 0,
  };

  enum MaxLenRuleCase {
    kMaxLen = 3,
    MAX_LEN_RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArrayRule* internal_default_instance() {
    return reinterpret_cast<const ArrayRule*>(
               &_ArrayRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ArrayRule* other);
  friend void swap(ArrayRule& a, ArrayRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArrayRule* New() const final {
    return CreateMaybeMessage<ArrayRule>(NULL);
  }

  ArrayRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArrayRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArrayRule& from);
  void MergeFrom(const ArrayRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArrayRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool not_empty = 1;
  void clear_not_empty();
  static const int kNotEmptyFieldNumber = 1;
  bool not_empty() const;
  void set_not_empty(bool value);

  // uint32 min_len = 2;
  private:
  bool has_min_len() const;
  public:
  void clear_min_len();
  static const int kMinLenFieldNumber = 2;
  ::google::protobuf::uint32 min_len() const;
  void set_min_len(::google::protobuf::uint32 value);

  // uint32 max_len = 3;
  private:
  bool has_max_len() const;
  public:
  void clear_max_len();
  static const int kMaxLenFieldNumber = 3;
  ::google::protobuf::uint32 max_len() const;
  void set_max_len(::google::protobuf::uint32 value);

  void clear_min_len_rule();
  MinLenRuleCase min_len_rule_case() const;
  void clear_max_len_rule();
  MaxLenRuleCase max_len_rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.ArrayRule)
 private:
  void set_has_min_len();
  void set_has_max_len();

  inline bool has_min_len_rule() const;
  inline void clear_has_min_len_rule();

  inline bool has_max_len_rule() const;
  inline void clear_has_max_len_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool not_empty_;
  union MinLenRuleUnion {
    MinLenRuleUnion() {}
    ::google::protobuf::uint32 min_len_;
  } min_len_rule_;
  union MaxLenRuleUnion {
    MaxLenRuleUnion() {}
    ::google::protobuf::uint32 max_len_;
  } max_len_rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValidateRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:validator.ValidateRules) */ {
 public:
  ValidateRules();
  virtual ~ValidateRules();

  ValidateRules(const ValidateRules& from);

  inline ValidateRules& operator=(const ValidateRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValidateRules(ValidateRules&& from) noexcept
    : ValidateRules() {
    *this = ::std::move(from);
  }

  inline ValidateRules& operator=(ValidateRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidateRules& default_instance();

  enum RuleCase {
    kInt32 = 1,
    kInt64 = 2,
    kUint32 = 3,
    kUint64 = 4,
    kFloat = 5,
    kDouble = 6,
    kString = 7,
    kEnum = 8,
    kArray = 9,
    RULE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidateRules* internal_default_instance() {
    return reinterpret_cast<const ValidateRules*>(
               &_ValidateRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ValidateRules* other);
  friend void swap(ValidateRules& a, ValidateRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValidateRules* New() const final {
    return CreateMaybeMessage<ValidateRules>(NULL);
  }

  ValidateRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValidateRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ValidateRules& from);
  void MergeFrom(const ValidateRules& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .validator.Int32Rule int32 = 1;
  bool has_int32() const;
  void clear_int32();
  static const int kInt32FieldNumber = 1;
  private:
  const ::validator::Int32Rule& _internal_int32() const;
  public:
  const ::validator::Int32Rule& int32() const;
  ::validator::Int32Rule* release_int32();
  ::validator::Int32Rule* mutable_int32();
  void set_allocated_int32(::validator::Int32Rule* int32);

  // .validator.Int64Rule int64 = 2;
  bool has_int64() const;
  void clear_int64();
  static const int kInt64FieldNumber = 2;
  private:
  const ::validator::Int64Rule& _internal_int64() const;
  public:
  const ::validator::Int64Rule& int64() const;
  ::validator::Int64Rule* release_int64();
  ::validator::Int64Rule* mutable_int64();
  void set_allocated_int64(::validator::Int64Rule* int64);

  // .validator.UInt32Rule uint32 = 3;
  bool has_uint32() const;
  void clear_uint32();
  static const int kUint32FieldNumber = 3;
  private:
  const ::validator::UInt32Rule& _internal_uint32() const;
  public:
  const ::validator::UInt32Rule& uint32() const;
  ::validator::UInt32Rule* release_uint32();
  ::validator::UInt32Rule* mutable_uint32();
  void set_allocated_uint32(::validator::UInt32Rule* uint32);

  // .validator.UInt64Rule uint64 = 4;
  bool has_uint64() const;
  void clear_uint64();
  static const int kUint64FieldNumber = 4;
  private:
  const ::validator::UInt64Rule& _internal_uint64() const;
  public:
  const ::validator::UInt64Rule& uint64() const;
  ::validator::UInt64Rule* release_uint64();
  ::validator::UInt64Rule* mutable_uint64();
  void set_allocated_uint64(::validator::UInt64Rule* uint64);

  // .validator.FloatRule float = 5;
  bool has_float_() const;
  void clear_float_();
  static const int kFloatFieldNumber = 5;
  private:
  const ::validator::FloatRule& _internal_float_() const;
  public:
  const ::validator::FloatRule& float_() const;
  ::validator::FloatRule* release_float_();
  ::validator::FloatRule* mutable_float_();
  void set_allocated_float_(::validator::FloatRule* float_);

  // .validator.DoubleRule double = 6;
  bool has_double_() const;
  void clear_double_();
  static const int kDoubleFieldNumber = 6;
  private:
  const ::validator::DoubleRule& _internal_double_() const;
  public:
  const ::validator::DoubleRule& double_() const;
  ::validator::DoubleRule* release_double_();
  ::validator::DoubleRule* mutable_double_();
  void set_allocated_double_(::validator::DoubleRule* double_);

  // .validator.StringRule string = 7;
  bool has_string() const;
  void clear_string();
  static const int kStringFieldNumber = 7;
  private:
  const ::validator::StringRule& _internal_string() const;
  public:
  const ::validator::StringRule& string() const;
  ::validator::StringRule* release_string();
  ::validator::StringRule* mutable_string();
  void set_allocated_string(::validator::StringRule* string);

  // .validator.EnumRule enum = 8;
  bool has_enum_() const;
  void clear_enum_();
  static const int kEnumFieldNumber = 8;
  private:
  const ::validator::EnumRule& _internal_enum_() const;
  public:
  const ::validator::EnumRule& enum_() const;
  ::validator::EnumRule* release_enum_();
  ::validator::EnumRule* mutable_enum_();
  void set_allocated_enum_(::validator::EnumRule* enum_);

  // .validator.ArrayRule array = 9;
  bool has_array() const;
  void clear_array();
  static const int kArrayFieldNumber = 9;
  private:
  const ::validator::ArrayRule& _internal_array() const;
  public:
  const ::validator::ArrayRule& array() const;
  ::validator::ArrayRule* release_array();
  ::validator::ArrayRule* mutable_array();
  void set_allocated_array(::validator::ArrayRule* array);

  void clear_rule();
  RuleCase rule_case() const;
  // @@protoc_insertion_point(class_scope:validator.ValidateRules)
 private:
  void set_has_int32();
  void set_has_int64();
  void set_has_uint32();
  void set_has_uint64();
  void set_has_float_();
  void set_has_double_();
  void set_has_string();
  void set_has_enum_();
  void set_has_array();

  inline bool has_rule() const;
  inline void clear_has_rule();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RuleUnion {
    RuleUnion() {}
    ::validator::Int32Rule* int32_;
    ::validator::Int64Rule* int64_;
    ::validator::UInt32Rule* uint32_;
    ::validator::UInt64Rule* uint64_;
    ::validator::FloatRule* float__;
    ::validator::DoubleRule* double__;
    ::validator::StringRule* string_;
    ::validator::EnumRule* enum__;
    ::validator::ArrayRule* array_;
  } rule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_validator_2eproto::TableStruct;
};
// ===================================================================

static const int kRuleFieldNumber = 10000;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::validator::ValidateRules >, 11, false >
  Rule;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Int32Rule

// int32 lt = 1;
inline bool Int32Rule::has_lt() const {
  return lt_rule_case() == kLt;
}
inline void Int32Rule::set_has_lt() {
  _oneof_case_[0] = kLt;
}
inline void Int32Rule::clear_lt() {
  if (has_lt()) {
    lt_rule_.lt_ = 0;
    clear_has_lt_rule();
  }
}
inline ::google::protobuf::int32 Int32Rule::lt() const {
  // @@protoc_insertion_point(field_get:validator.Int32Rule.lt)
  if (has_lt()) {
    return lt_rule_.lt_;
  }
  return 0;
}
inline void Int32Rule::set_lt(::google::protobuf::int32 value) {
  if (!has_lt()) {
    clear_lt_rule();
    set_has_lt();
  }
  lt_rule_.lt_ = value;
  // @@protoc_insertion_point(field_set:validator.Int32Rule.lt)
}

// int32 lte = 2;
inline bool Int32Rule::has_lte() const {
  return lte_rule_case() == kLte;
}
inline void Int32Rule::set_has_lte() {
  _oneof_case_[1] = kLte;
}
inline void Int32Rule::clear_lte() {
  if (has_lte()) {
    lte_rule_.lte_ = 0;
    clear_has_lte_rule();
  }
}
inline ::google::protobuf::int32 Int32Rule::lte() const {
  // @@protoc_insertion_point(field_get:validator.Int32Rule.lte)
  if (has_lte()) {
    return lte_rule_.lte_;
  }
  return 0;
}
inline void Int32Rule::set_lte(::google::protobuf::int32 value) {
  if (!has_lte()) {
    clear_lte_rule();
    set_has_lte();
  }
  lte_rule_.lte_ = value;
  // @@protoc_insertion_point(field_set:validator.Int32Rule.lte)
}

// int32 gt = 3;
inline bool Int32Rule::has_gt() const {
  return gt_rule_case() == kGt;
}
inline void Int32Rule::set_has_gt() {
  _oneof_case_[2] = kGt;
}
inline void Int32Rule::clear_gt() {
  if (has_gt()) {
    gt_rule_.gt_ = 0;
    clear_has_gt_rule();
  }
}
inline ::google::protobuf::int32 Int32Rule::gt() const {
  // @@protoc_insertion_point(field_get:validator.Int32Rule.gt)
  if (has_gt()) {
    return gt_rule_.gt_;
  }
  return 0;
}
inline void Int32Rule::set_gt(::google::protobuf::int32 value) {
  if (!has_gt()) {
    clear_gt_rule();
    set_has_gt();
  }
  gt_rule_.gt_ = value;
  // @@protoc_insertion_point(field_set:validator.Int32Rule.gt)
}

// int32 gte = 4;
inline bool Int32Rule::has_gte() const {
  return gte_rule_case() == kGte;
}
inline void Int32Rule::set_has_gte() {
  _oneof_case_[3] = kGte;
}
inline void Int32Rule::clear_gte() {
  if (has_gte()) {
    gte_rule_.gte_ = 0;
    clear_has_gte_rule();
  }
}
inline ::google::protobuf::int32 Int32Rule::gte() const {
  // @@protoc_insertion_point(field_get:validator.Int32Rule.gte)
  if (has_gte()) {
    return gte_rule_.gte_;
  }
  return 0;
}
inline void Int32Rule::set_gte(::google::protobuf::int32 value) {
  if (!has_gte()) {
    clear_gte_rule();
    set_has_gte();
  }
  gte_rule_.gte_ = value;
  // @@protoc_insertion_point(field_set:validator.Int32Rule.gte)
}

// repeated int32 in = 5;
inline int Int32Rule::in_size() const {
  return in_.size();
}
inline void Int32Rule::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 Int32Rule::in(int index) const {
  // @@protoc_insertion_point(field_get:validator.Int32Rule.in)
  return in_.Get(index);
}
inline void Int32Rule::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.Int32Rule.in)
}
inline void Int32Rule::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.Int32Rule.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Int32Rule::in() const {
  // @@protoc_insertion_point(field_list:validator.Int32Rule.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Int32Rule::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.Int32Rule.in)
  return &in_;
}

// repeated int32 not_in = 6;
inline int Int32Rule::not_in_size() const {
  return not_in_.size();
}
inline void Int32Rule::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int32 Int32Rule::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validator.Int32Rule.not_in)
  return not_in_.Get(index);
}
inline void Int32Rule::set_not_in(int index, ::google::protobuf::int32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.Int32Rule.not_in)
}
inline void Int32Rule::add_not_in(::google::protobuf::int32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.Int32Rule.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Int32Rule::not_in() const {
  // @@protoc_insertion_point(field_list:validator.Int32Rule.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Int32Rule::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.Int32Rule.not_in)
  return &not_in_;
}

inline bool Int32Rule::has_lt_rule() const {
  return lt_rule_case() != LT_RULE_NOT_SET;
}
inline void Int32Rule::clear_has_lt_rule() {
  _oneof_case_[0] = LT_RULE_NOT_SET;
}
inline bool Int32Rule::has_lte_rule() const {
  return lte_rule_case() != LTE_RULE_NOT_SET;
}
inline void Int32Rule::clear_has_lte_rule() {
  _oneof_case_[1] = LTE_RULE_NOT_SET;
}
inline bool Int32Rule::has_gt_rule() const {
  return gt_rule_case() != GT_RULE_NOT_SET;
}
inline void Int32Rule::clear_has_gt_rule() {
  _oneof_case_[2] = GT_RULE_NOT_SET;
}
inline bool Int32Rule::has_gte_rule() const {
  return gte_rule_case() != GTE_RULE_NOT_SET;
}
inline void Int32Rule::clear_has_gte_rule() {
  _oneof_case_[3] = GTE_RULE_NOT_SET;
}
inline Int32Rule::LtRuleCase Int32Rule::lt_rule_case() const {
  return Int32Rule::LtRuleCase(_oneof_case_[0]);
}
inline Int32Rule::LteRuleCase Int32Rule::lte_rule_case() const {
  return Int32Rule::LteRuleCase(_oneof_case_[1]);
}
inline Int32Rule::GtRuleCase Int32Rule::gt_rule_case() const {
  return Int32Rule::GtRuleCase(_oneof_case_[2]);
}
inline Int32Rule::GteRuleCase Int32Rule::gte_rule_case() const {
  return Int32Rule::GteRuleCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// Int64Rule

// int64 lt = 1;
inline bool Int64Rule::has_lt() const {
  return lt_rule_case() == kLt;
}
inline void Int64Rule::set_has_lt() {
  _oneof_case_[0] = kLt;
}
inline void Int64Rule::clear_lt() {
  if (has_lt()) {
    lt_rule_.lt_ = GOOGLE_LONGLONG(0);
    clear_has_lt_rule();
  }
}
inline ::google::protobuf::int64 Int64Rule::lt() const {
  // @@protoc_insertion_point(field_get:validator.Int64Rule.lt)
  if (has_lt()) {
    return lt_rule_.lt_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Int64Rule::set_lt(::google::protobuf::int64 value) {
  if (!has_lt()) {
    clear_lt_rule();
    set_has_lt();
  }
  lt_rule_.lt_ = value;
  // @@protoc_insertion_point(field_set:validator.Int64Rule.lt)
}

// int64 lte = 2;
inline bool Int64Rule::has_lte() const {
  return lte_rule_case() == kLte;
}
inline void Int64Rule::set_has_lte() {
  _oneof_case_[1] = kLte;
}
inline void Int64Rule::clear_lte() {
  if (has_lte()) {
    lte_rule_.lte_ = GOOGLE_LONGLONG(0);
    clear_has_lte_rule();
  }
}
inline ::google::protobuf::int64 Int64Rule::lte() const {
  // @@protoc_insertion_point(field_get:validator.Int64Rule.lte)
  if (has_lte()) {
    return lte_rule_.lte_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Int64Rule::set_lte(::google::protobuf::int64 value) {
  if (!has_lte()) {
    clear_lte_rule();
    set_has_lte();
  }
  lte_rule_.lte_ = value;
  // @@protoc_insertion_point(field_set:validator.Int64Rule.lte)
}

// int64 gt = 3;
inline bool Int64Rule::has_gt() const {
  return gt_rule_case() == kGt;
}
inline void Int64Rule::set_has_gt() {
  _oneof_case_[2] = kGt;
}
inline void Int64Rule::clear_gt() {
  if (has_gt()) {
    gt_rule_.gt_ = GOOGLE_LONGLONG(0);
    clear_has_gt_rule();
  }
}
inline ::google::protobuf::int64 Int64Rule::gt() const {
  // @@protoc_insertion_point(field_get:validator.Int64Rule.gt)
  if (has_gt()) {
    return gt_rule_.gt_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Int64Rule::set_gt(::google::protobuf::int64 value) {
  if (!has_gt()) {
    clear_gt_rule();
    set_has_gt();
  }
  gt_rule_.gt_ = value;
  // @@protoc_insertion_point(field_set:validator.Int64Rule.gt)
}

// int64 gte = 4;
inline bool Int64Rule::has_gte() const {
  return gte_rule_case() == kGte;
}
inline void Int64Rule::set_has_gte() {
  _oneof_case_[3] = kGte;
}
inline void Int64Rule::clear_gte() {
  if (has_gte()) {
    gte_rule_.gte_ = GOOGLE_LONGLONG(0);
    clear_has_gte_rule();
  }
}
inline ::google::protobuf::int64 Int64Rule::gte() const {
  // @@protoc_insertion_point(field_get:validator.Int64Rule.gte)
  if (has_gte()) {
    return gte_rule_.gte_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Int64Rule::set_gte(::google::protobuf::int64 value) {
  if (!has_gte()) {
    clear_gte_rule();
    set_has_gte();
  }
  gte_rule_.gte_ = value;
  // @@protoc_insertion_point(field_set:validator.Int64Rule.gte)
}

// repeated int64 in = 5;
inline int Int64Rule::in_size() const {
  return in_.size();
}
inline void Int64Rule::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int64 Int64Rule::in(int index) const {
  // @@protoc_insertion_point(field_get:validator.Int64Rule.in)
  return in_.Get(index);
}
inline void Int64Rule::set_in(int index, ::google::protobuf::int64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.Int64Rule.in)
}
inline void Int64Rule::add_in(::google::protobuf::int64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.Int64Rule.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Rule::in() const {
  // @@protoc_insertion_point(field_list:validator.Int64Rule.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Rule::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.Int64Rule.in)
  return &in_;
}

// repeated int64 not_in = 6;
inline int Int64Rule::not_in_size() const {
  return not_in_.size();
}
inline void Int64Rule::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::int64 Int64Rule::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validator.Int64Rule.not_in)
  return not_in_.Get(index);
}
inline void Int64Rule::set_not_in(int index, ::google::protobuf::int64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.Int64Rule.not_in)
}
inline void Int64Rule::add_not_in(::google::protobuf::int64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.Int64Rule.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Rule::not_in() const {
  // @@protoc_insertion_point(field_list:validator.Int64Rule.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Rule::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.Int64Rule.not_in)
  return &not_in_;
}

inline bool Int64Rule::has_lt_rule() const {
  return lt_rule_case() != LT_RULE_NOT_SET;
}
inline void Int64Rule::clear_has_lt_rule() {
  _oneof_case_[0] = LT_RULE_NOT_SET;
}
inline bool Int64Rule::has_lte_rule() const {
  return lte_rule_case() != LTE_RULE_NOT_SET;
}
inline void Int64Rule::clear_has_lte_rule() {
  _oneof_case_[1] = LTE_RULE_NOT_SET;
}
inline bool Int64Rule::has_gt_rule() const {
  return gt_rule_case() != GT_RULE_NOT_SET;
}
inline void Int64Rule::clear_has_gt_rule() {
  _oneof_case_[2] = GT_RULE_NOT_SET;
}
inline bool Int64Rule::has_gte_rule() const {
  return gte_rule_case() != GTE_RULE_NOT_SET;
}
inline void Int64Rule::clear_has_gte_rule() {
  _oneof_case_[3] = GTE_RULE_NOT_SET;
}
inline Int64Rule::LtRuleCase Int64Rule::lt_rule_case() const {
  return Int64Rule::LtRuleCase(_oneof_case_[0]);
}
inline Int64Rule::LteRuleCase Int64Rule::lte_rule_case() const {
  return Int64Rule::LteRuleCase(_oneof_case_[1]);
}
inline Int64Rule::GtRuleCase Int64Rule::gt_rule_case() const {
  return Int64Rule::GtRuleCase(_oneof_case_[2]);
}
inline Int64Rule::GteRuleCase Int64Rule::gte_rule_case() const {
  return Int64Rule::GteRuleCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// UInt32Rule

// uint32 lt = 1;
inline bool UInt32Rule::has_lt() const {
  return lt_rule_case() == kLt;
}
inline void UInt32Rule::set_has_lt() {
  _oneof_case_[0] = kLt;
}
inline void UInt32Rule::clear_lt() {
  if (has_lt()) {
    lt_rule_.lt_ = 0u;
    clear_has_lt_rule();
  }
}
inline ::google::protobuf::uint32 UInt32Rule::lt() const {
  // @@protoc_insertion_point(field_get:validator.UInt32Rule.lt)
  if (has_lt()) {
    return lt_rule_.lt_;
  }
  return 0u;
}
inline void UInt32Rule::set_lt(::google::protobuf::uint32 value) {
  if (!has_lt()) {
    clear_lt_rule();
    set_has_lt();
  }
  lt_rule_.lt_ = value;
  // @@protoc_insertion_point(field_set:validator.UInt32Rule.lt)
}

// uint32 lte = 2;
inline bool UInt32Rule::has_lte() const {
  return lte_rule_case() == kLte;
}
inline void UInt32Rule::set_has_lte() {
  _oneof_case_[1] = kLte;
}
inline void UInt32Rule::clear_lte() {
  if (has_lte()) {
    lte_rule_.lte_ = 0u;
    clear_has_lte_rule();
  }
}
inline ::google::protobuf::uint32 UInt32Rule::lte() const {
  // @@protoc_insertion_point(field_get:validator.UInt32Rule.lte)
  if (has_lte()) {
    return lte_rule_.lte_;
  }
  return 0u;
}
inline void UInt32Rule::set_lte(::google::protobuf::uint32 value) {
  if (!has_lte()) {
    clear_lte_rule();
    set_has_lte();
  }
  lte_rule_.lte_ = value;
  // @@protoc_insertion_point(field_set:validator.UInt32Rule.lte)
}

// uint32 gt = 3;
inline bool UInt32Rule::has_gt() const {
  return gt_rule_case() == kGt;
}
inline void UInt32Rule::set_has_gt() {
  _oneof_case_[2] = kGt;
}
inline void UInt32Rule::clear_gt() {
  if (has_gt()) {
    gt_rule_.gt_ = 0u;
    clear_has_gt_rule();
  }
}
inline ::google::protobuf::uint32 UInt32Rule::gt() const {
  // @@protoc_insertion_point(field_get:validator.UInt32Rule.gt)
  if (has_gt()) {
    return gt_rule_.gt_;
  }
  return 0u;
}
inline void UInt32Rule::set_gt(::google::protobuf::uint32 value) {
  if (!has_gt()) {
    clear_gt_rule();
    set_has_gt();
  }
  gt_rule_.gt_ = value;
  // @@protoc_insertion_point(field_set:validator.UInt32Rule.gt)
}

// uint32 gte = 4;
inline bool UInt32Rule::has_gte() const {
  return gte_rule_case() == kGte;
}
inline void UInt32Rule::set_has_gte() {
  _oneof_case_[3] = kGte;
}
inline void UInt32Rule::clear_gte() {
  if (has_gte()) {
    gte_rule_.gte_ = 0u;
    clear_has_gte_rule();
  }
}
inline ::google::protobuf::uint32 UInt32Rule::gte() const {
  // @@protoc_insertion_point(field_get:validator.UInt32Rule.gte)
  if (has_gte()) {
    return gte_rule_.gte_;
  }
  return 0u;
}
inline void UInt32Rule::set_gte(::google::protobuf::uint32 value) {
  if (!has_gte()) {
    clear_gte_rule();
    set_has_gte();
  }
  gte_rule_.gte_ = value;
  // @@protoc_insertion_point(field_set:validator.UInt32Rule.gte)
}

// repeated uint32 in = 5;
inline int UInt32Rule::in_size() const {
  return in_.size();
}
inline void UInt32Rule::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint32 UInt32Rule::in(int index) const {
  // @@protoc_insertion_point(field_get:validator.UInt32Rule.in)
  return in_.Get(index);
}
inline void UInt32Rule::set_in(int index, ::google::protobuf::uint32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.UInt32Rule.in)
}
inline void UInt32Rule::add_in(::google::protobuf::uint32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.UInt32Rule.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UInt32Rule::in() const {
  // @@protoc_insertion_point(field_list:validator.UInt32Rule.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UInt32Rule::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.UInt32Rule.in)
  return &in_;
}

// repeated uint32 not_in = 6;
inline int UInt32Rule::not_in_size() const {
  return not_in_.size();
}
inline void UInt32Rule::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint32 UInt32Rule::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validator.UInt32Rule.not_in)
  return not_in_.Get(index);
}
inline void UInt32Rule::set_not_in(int index, ::google::protobuf::uint32 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.UInt32Rule.not_in)
}
inline void UInt32Rule::add_not_in(::google::protobuf::uint32 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.UInt32Rule.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UInt32Rule::not_in() const {
  // @@protoc_insertion_point(field_list:validator.UInt32Rule.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UInt32Rule::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.UInt32Rule.not_in)
  return &not_in_;
}

inline bool UInt32Rule::has_lt_rule() const {
  return lt_rule_case() != LT_RULE_NOT_SET;
}
inline void UInt32Rule::clear_has_lt_rule() {
  _oneof_case_[0] = LT_RULE_NOT_SET;
}
inline bool UInt32Rule::has_lte_rule() const {
  return lte_rule_case() != LTE_RULE_NOT_SET;
}
inline void UInt32Rule::clear_has_lte_rule() {
  _oneof_case_[1] = LTE_RULE_NOT_SET;
}
inline bool UInt32Rule::has_gt_rule() const {
  return gt_rule_case() != GT_RULE_NOT_SET;
}
inline void UInt32Rule::clear_has_gt_rule() {
  _oneof_case_[2] = GT_RULE_NOT_SET;
}
inline bool UInt32Rule::has_gte_rule() const {
  return gte_rule_case() != GTE_RULE_NOT_SET;
}
inline void UInt32Rule::clear_has_gte_rule() {
  _oneof_case_[3] = GTE_RULE_NOT_SET;
}
inline UInt32Rule::LtRuleCase UInt32Rule::lt_rule_case() const {
  return UInt32Rule::LtRuleCase(_oneof_case_[0]);
}
inline UInt32Rule::LteRuleCase UInt32Rule::lte_rule_case() const {
  return UInt32Rule::LteRuleCase(_oneof_case_[1]);
}
inline UInt32Rule::GtRuleCase UInt32Rule::gt_rule_case() const {
  return UInt32Rule::GtRuleCase(_oneof_case_[2]);
}
inline UInt32Rule::GteRuleCase UInt32Rule::gte_rule_case() const {
  return UInt32Rule::GteRuleCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// UInt64Rule

// uint64 lt = 1;
inline bool UInt64Rule::has_lt() const {
  return lt_rule_case() == kLt;
}
inline void UInt64Rule::set_has_lt() {
  _oneof_case_[0] = kLt;
}
inline void UInt64Rule::clear_lt() {
  if (has_lt()) {
    lt_rule_.lt_ = GOOGLE_ULONGLONG(0);
    clear_has_lt_rule();
  }
}
inline ::google::protobuf::uint64 UInt64Rule::lt() const {
  // @@protoc_insertion_point(field_get:validator.UInt64Rule.lt)
  if (has_lt()) {
    return lt_rule_.lt_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void UInt64Rule::set_lt(::google::protobuf::uint64 value) {
  if (!has_lt()) {
    clear_lt_rule();
    set_has_lt();
  }
  lt_rule_.lt_ = value;
  // @@protoc_insertion_point(field_set:validator.UInt64Rule.lt)
}

// uint64 lte = 2;
inline bool UInt64Rule::has_lte() const {
  return lte_rule_case() == kLte;
}
inline void UInt64Rule::set_has_lte() {
  _oneof_case_[1] = kLte;
}
inline void UInt64Rule::clear_lte() {
  if (has_lte()) {
    lte_rule_.lte_ = GOOGLE_ULONGLONG(0);
    clear_has_lte_rule();
  }
}
inline ::google::protobuf::uint64 UInt64Rule::lte() const {
  // @@protoc_insertion_point(field_get:validator.UInt64Rule.lte)
  if (has_lte()) {
    return lte_rule_.lte_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void UInt64Rule::set_lte(::google::protobuf::uint64 value) {
  if (!has_lte()) {
    clear_lte_rule();
    set_has_lte();
  }
  lte_rule_.lte_ = value;
  // @@protoc_insertion_point(field_set:validator.UInt64Rule.lte)
}

// uint64 gt = 3;
inline bool UInt64Rule::has_gt() const {
  return gt_rule_case() == kGt;
}
inline void UInt64Rule::set_has_gt() {
  _oneof_case_[2] = kGt;
}
inline void UInt64Rule::clear_gt() {
  if (has_gt()) {
    gt_rule_.gt_ = GOOGLE_ULONGLONG(0);
    clear_has_gt_rule();
  }
}
inline ::google::protobuf::uint64 UInt64Rule::gt() const {
  // @@protoc_insertion_point(field_get:validator.UInt64Rule.gt)
  if (has_gt()) {
    return gt_rule_.gt_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void UInt64Rule::set_gt(::google::protobuf::uint64 value) {
  if (!has_gt()) {
    clear_gt_rule();
    set_has_gt();
  }
  gt_rule_.gt_ = value;
  // @@protoc_insertion_point(field_set:validator.UInt64Rule.gt)
}

// uint64 gte = 4;
inline bool UInt64Rule::has_gte() const {
  return gte_rule_case() == kGte;
}
inline void UInt64Rule::set_has_gte() {
  _oneof_case_[3] = kGte;
}
inline void UInt64Rule::clear_gte() {
  if (has_gte()) {
    gte_rule_.gte_ = GOOGLE_ULONGLONG(0);
    clear_has_gte_rule();
  }
}
inline ::google::protobuf::uint64 UInt64Rule::gte() const {
  // @@protoc_insertion_point(field_get:validator.UInt64Rule.gte)
  if (has_gte()) {
    return gte_rule_.gte_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void UInt64Rule::set_gte(::google::protobuf::uint64 value) {
  if (!has_gte()) {
    clear_gte_rule();
    set_has_gte();
  }
  gte_rule_.gte_ = value;
  // @@protoc_insertion_point(field_set:validator.UInt64Rule.gte)
}

// repeated uint64 in = 5;
inline int UInt64Rule::in_size() const {
  return in_.size();
}
inline void UInt64Rule::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::uint64 UInt64Rule::in(int index) const {
  // @@protoc_insertion_point(field_get:validator.UInt64Rule.in)
  return in_.Get(index);
}
inline void UInt64Rule::set_in(int index, ::google::protobuf::uint64 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.UInt64Rule.in)
}
inline void UInt64Rule::add_in(::google::protobuf::uint64 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.UInt64Rule.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UInt64Rule::in() const {
  // @@protoc_insertion_point(field_list:validator.UInt64Rule.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UInt64Rule::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.UInt64Rule.in)
  return &in_;
}

// repeated uint64 not_in = 6;
inline int UInt64Rule::not_in_size() const {
  return not_in_.size();
}
inline void UInt64Rule::clear_not_in() {
  not_in_.Clear();
}
inline ::google::protobuf::uint64 UInt64Rule::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validator.UInt64Rule.not_in)
  return not_in_.Get(index);
}
inline void UInt64Rule::set_not_in(int index, ::google::protobuf::uint64 value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.UInt64Rule.not_in)
}
inline void UInt64Rule::add_not_in(::google::protobuf::uint64 value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.UInt64Rule.not_in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UInt64Rule::not_in() const {
  // @@protoc_insertion_point(field_list:validator.UInt64Rule.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UInt64Rule::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.UInt64Rule.not_in)
  return &not_in_;
}

inline bool UInt64Rule::has_lt_rule() const {
  return lt_rule_case() != LT_RULE_NOT_SET;
}
inline void UInt64Rule::clear_has_lt_rule() {
  _oneof_case_[0] = LT_RULE_NOT_SET;
}
inline bool UInt64Rule::has_lte_rule() const {
  return lte_rule_case() != LTE_RULE_NOT_SET;
}
inline void UInt64Rule::clear_has_lte_rule() {
  _oneof_case_[1] = LTE_RULE_NOT_SET;
}
inline bool UInt64Rule::has_gt_rule() const {
  return gt_rule_case() != GT_RULE_NOT_SET;
}
inline void UInt64Rule::clear_has_gt_rule() {
  _oneof_case_[2] = GT_RULE_NOT_SET;
}
inline bool UInt64Rule::has_gte_rule() const {
  return gte_rule_case() != GTE_RULE_NOT_SET;
}
inline void UInt64Rule::clear_has_gte_rule() {
  _oneof_case_[3] = GTE_RULE_NOT_SET;
}
inline UInt64Rule::LtRuleCase UInt64Rule::lt_rule_case() const {
  return UInt64Rule::LtRuleCase(_oneof_case_[0]);
}
inline UInt64Rule::LteRuleCase UInt64Rule::lte_rule_case() const {
  return UInt64Rule::LteRuleCase(_oneof_case_[1]);
}
inline UInt64Rule::GtRuleCase UInt64Rule::gt_rule_case() const {
  return UInt64Rule::GtRuleCase(_oneof_case_[2]);
}
inline UInt64Rule::GteRuleCase UInt64Rule::gte_rule_case() const {
  return UInt64Rule::GteRuleCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// FloatRule

// float lt = 1;
inline bool FloatRule::has_lt() const {
  return lt_rule_case() == kLt;
}
inline void FloatRule::set_has_lt() {
  _oneof_case_[0] = kLt;
}
inline void FloatRule::clear_lt() {
  if (has_lt()) {
    lt_rule_.lt_ = 0;
    clear_has_lt_rule();
  }
}
inline float FloatRule::lt() const {
  // @@protoc_insertion_point(field_get:validator.FloatRule.lt)
  if (has_lt()) {
    return lt_rule_.lt_;
  }
  return 0;
}
inline void FloatRule::set_lt(float value) {
  if (!has_lt()) {
    clear_lt_rule();
    set_has_lt();
  }
  lt_rule_.lt_ = value;
  // @@protoc_insertion_point(field_set:validator.FloatRule.lt)
}

// float lte = 2;
inline bool FloatRule::has_lte() const {
  return lte_rule_case() == kLte;
}
inline void FloatRule::set_has_lte() {
  _oneof_case_[1] = kLte;
}
inline void FloatRule::clear_lte() {
  if (has_lte()) {
    lte_rule_.lte_ = 0;
    clear_has_lte_rule();
  }
}
inline float FloatRule::lte() const {
  // @@protoc_insertion_point(field_get:validator.FloatRule.lte)
  if (has_lte()) {
    return lte_rule_.lte_;
  }
  return 0;
}
inline void FloatRule::set_lte(float value) {
  if (!has_lte()) {
    clear_lte_rule();
    set_has_lte();
  }
  lte_rule_.lte_ = value;
  // @@protoc_insertion_point(field_set:validator.FloatRule.lte)
}

// float gt = 3;
inline bool FloatRule::has_gt() const {
  return gt_rule_case() == kGt;
}
inline void FloatRule::set_has_gt() {
  _oneof_case_[2] = kGt;
}
inline void FloatRule::clear_gt() {
  if (has_gt()) {
    gt_rule_.gt_ = 0;
    clear_has_gt_rule();
  }
}
inline float FloatRule::gt() const {
  // @@protoc_insertion_point(field_get:validator.FloatRule.gt)
  if (has_gt()) {
    return gt_rule_.gt_;
  }
  return 0;
}
inline void FloatRule::set_gt(float value) {
  if (!has_gt()) {
    clear_gt_rule();
    set_has_gt();
  }
  gt_rule_.gt_ = value;
  // @@protoc_insertion_point(field_set:validator.FloatRule.gt)
}

// float gte = 4;
inline bool FloatRule::has_gte() const {
  return gte_rule_case() == kGte;
}
inline void FloatRule::set_has_gte() {
  _oneof_case_[3] = kGte;
}
inline void FloatRule::clear_gte() {
  if (has_gte()) {
    gte_rule_.gte_ = 0;
    clear_has_gte_rule();
  }
}
inline float FloatRule::gte() const {
  // @@protoc_insertion_point(field_get:validator.FloatRule.gte)
  if (has_gte()) {
    return gte_rule_.gte_;
  }
  return 0;
}
inline void FloatRule::set_gte(float value) {
  if (!has_gte()) {
    clear_gte_rule();
    set_has_gte();
  }
  gte_rule_.gte_ = value;
  // @@protoc_insertion_point(field_set:validator.FloatRule.gte)
}

// repeated float in = 5;
inline int FloatRule::in_size() const {
  return in_.size();
}
inline void FloatRule::clear_in() {
  in_.Clear();
}
inline float FloatRule::in(int index) const {
  // @@protoc_insertion_point(field_get:validator.FloatRule.in)
  return in_.Get(index);
}
inline void FloatRule::set_in(int index, float value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.FloatRule.in)
}
inline void FloatRule::add_in(float value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.FloatRule.in)
}
inline const ::google::protobuf::RepeatedField< float >&
FloatRule::in() const {
  // @@protoc_insertion_point(field_list:validator.FloatRule.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatRule::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.FloatRule.in)
  return &in_;
}

// repeated float not_in = 6;
inline int FloatRule::not_in_size() const {
  return not_in_.size();
}
inline void FloatRule::clear_not_in() {
  not_in_.Clear();
}
inline float FloatRule::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validator.FloatRule.not_in)
  return not_in_.Get(index);
}
inline void FloatRule::set_not_in(int index, float value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.FloatRule.not_in)
}
inline void FloatRule::add_not_in(float value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.FloatRule.not_in)
}
inline const ::google::protobuf::RepeatedField< float >&
FloatRule::not_in() const {
  // @@protoc_insertion_point(field_list:validator.FloatRule.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatRule::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.FloatRule.not_in)
  return &not_in_;
}

inline bool FloatRule::has_lt_rule() const {
  return lt_rule_case() != LT_RULE_NOT_SET;
}
inline void FloatRule::clear_has_lt_rule() {
  _oneof_case_[0] = LT_RULE_NOT_SET;
}
inline bool FloatRule::has_lte_rule() const {
  return lte_rule_case() != LTE_RULE_NOT_SET;
}
inline void FloatRule::clear_has_lte_rule() {
  _oneof_case_[1] = LTE_RULE_NOT_SET;
}
inline bool FloatRule::has_gt_rule() const {
  return gt_rule_case() != GT_RULE_NOT_SET;
}
inline void FloatRule::clear_has_gt_rule() {
  _oneof_case_[2] = GT_RULE_NOT_SET;
}
inline bool FloatRule::has_gte_rule() const {
  return gte_rule_case() != GTE_RULE_NOT_SET;
}
inline void FloatRule::clear_has_gte_rule() {
  _oneof_case_[3] = GTE_RULE_NOT_SET;
}
inline FloatRule::LtRuleCase FloatRule::lt_rule_case() const {
  return FloatRule::LtRuleCase(_oneof_case_[0]);
}
inline FloatRule::LteRuleCase FloatRule::lte_rule_case() const {
  return FloatRule::LteRuleCase(_oneof_case_[1]);
}
inline FloatRule::GtRuleCase FloatRule::gt_rule_case() const {
  return FloatRule::GtRuleCase(_oneof_case_[2]);
}
inline FloatRule::GteRuleCase FloatRule::gte_rule_case() const {
  return FloatRule::GteRuleCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// DoubleRule

// double lt = 1;
inline bool DoubleRule::has_lt() const {
  return lt_rule_case() == kLt;
}
inline void DoubleRule::set_has_lt() {
  _oneof_case_[0] = kLt;
}
inline void DoubleRule::clear_lt() {
  if (has_lt()) {
    lt_rule_.lt_ = 0;
    clear_has_lt_rule();
  }
}
inline double DoubleRule::lt() const {
  // @@protoc_insertion_point(field_get:validator.DoubleRule.lt)
  if (has_lt()) {
    return lt_rule_.lt_;
  }
  return 0;
}
inline void DoubleRule::set_lt(double value) {
  if (!has_lt()) {
    clear_lt_rule();
    set_has_lt();
  }
  lt_rule_.lt_ = value;
  // @@protoc_insertion_point(field_set:validator.DoubleRule.lt)
}

// double lte = 2;
inline bool DoubleRule::has_lte() const {
  return lte_rule_case() == kLte;
}
inline void DoubleRule::set_has_lte() {
  _oneof_case_[1] = kLte;
}
inline void DoubleRule::clear_lte() {
  if (has_lte()) {
    lte_rule_.lte_ = 0;
    clear_has_lte_rule();
  }
}
inline double DoubleRule::lte() const {
  // @@protoc_insertion_point(field_get:validator.DoubleRule.lte)
  if (has_lte()) {
    return lte_rule_.lte_;
  }
  return 0;
}
inline void DoubleRule::set_lte(double value) {
  if (!has_lte()) {
    clear_lte_rule();
    set_has_lte();
  }
  lte_rule_.lte_ = value;
  // @@protoc_insertion_point(field_set:validator.DoubleRule.lte)
}

// double gt = 3;
inline bool DoubleRule::has_gt() const {
  return gt_rule_case() == kGt;
}
inline void DoubleRule::set_has_gt() {
  _oneof_case_[2] = kGt;
}
inline void DoubleRule::clear_gt() {
  if (has_gt()) {
    gt_rule_.gt_ = 0;
    clear_has_gt_rule();
  }
}
inline double DoubleRule::gt() const {
  // @@protoc_insertion_point(field_get:validator.DoubleRule.gt)
  if (has_gt()) {
    return gt_rule_.gt_;
  }
  return 0;
}
inline void DoubleRule::set_gt(double value) {
  if (!has_gt()) {
    clear_gt_rule();
    set_has_gt();
  }
  gt_rule_.gt_ = value;
  // @@protoc_insertion_point(field_set:validator.DoubleRule.gt)
}

// double gte = 4;
inline bool DoubleRule::has_gte() const {
  return gte_rule_case() == kGte;
}
inline void DoubleRule::set_has_gte() {
  _oneof_case_[3] = kGte;
}
inline void DoubleRule::clear_gte() {
  if (has_gte()) {
    gte_rule_.gte_ = 0;
    clear_has_gte_rule();
  }
}
inline double DoubleRule::gte() const {
  // @@protoc_insertion_point(field_get:validator.DoubleRule.gte)
  if (has_gte()) {
    return gte_rule_.gte_;
  }
  return 0;
}
inline void DoubleRule::set_gte(double value) {
  if (!has_gte()) {
    clear_gte_rule();
    set_has_gte();
  }
  gte_rule_.gte_ = value;
  // @@protoc_insertion_point(field_set:validator.DoubleRule.gte)
}

// repeated double in = 5;
inline int DoubleRule::in_size() const {
  return in_.size();
}
inline void DoubleRule::clear_in() {
  in_.Clear();
}
inline double DoubleRule::in(int index) const {
  // @@protoc_insertion_point(field_get:validator.DoubleRule.in)
  return in_.Get(index);
}
inline void DoubleRule::set_in(int index, double value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.DoubleRule.in)
}
inline void DoubleRule::add_in(double value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.DoubleRule.in)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleRule::in() const {
  // @@protoc_insertion_point(field_list:validator.DoubleRule.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleRule::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.DoubleRule.in)
  return &in_;
}

// repeated double not_in = 6;
inline int DoubleRule::not_in_size() const {
  return not_in_.size();
}
inline void DoubleRule::clear_not_in() {
  not_in_.Clear();
}
inline double DoubleRule::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validator.DoubleRule.not_in)
  return not_in_.Get(index);
}
inline void DoubleRule::set_not_in(int index, double value) {
  not_in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.DoubleRule.not_in)
}
inline void DoubleRule::add_not_in(double value) {
  not_in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.DoubleRule.not_in)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleRule::not_in() const {
  // @@protoc_insertion_point(field_list:validator.DoubleRule.not_in)
  return not_in_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleRule::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.DoubleRule.not_in)
  return &not_in_;
}

inline bool DoubleRule::has_lt_rule() const {
  return lt_rule_case() != LT_RULE_NOT_SET;
}
inline void DoubleRule::clear_has_lt_rule() {
  _oneof_case_[0] = LT_RULE_NOT_SET;
}
inline bool DoubleRule::has_lte_rule() const {
  return lte_rule_case() != LTE_RULE_NOT_SET;
}
inline void DoubleRule::clear_has_lte_rule() {
  _oneof_case_[1] = LTE_RULE_NOT_SET;
}
inline bool DoubleRule::has_gt_rule() const {
  return gt_rule_case() != GT_RULE_NOT_SET;
}
inline void DoubleRule::clear_has_gt_rule() {
  _oneof_case_[2] = GT_RULE_NOT_SET;
}
inline bool DoubleRule::has_gte_rule() const {
  return gte_rule_case() != GTE_RULE_NOT_SET;
}
inline void DoubleRule::clear_has_gte_rule() {
  _oneof_case_[3] = GTE_RULE_NOT_SET;
}
inline DoubleRule::LtRuleCase DoubleRule::lt_rule_case() const {
  return DoubleRule::LtRuleCase(_oneof_case_[0]);
}
inline DoubleRule::LteRuleCase DoubleRule::lte_rule_case() const {
  return DoubleRule::LteRuleCase(_oneof_case_[1]);
}
inline DoubleRule::GtRuleCase DoubleRule::gt_rule_case() const {
  return DoubleRule::GtRuleCase(_oneof_case_[2]);
}
inline DoubleRule::GteRuleCase DoubleRule::gte_rule_case() const {
  return DoubleRule::GteRuleCase(_oneof_case_[3]);
}
// -------------------------------------------------------------------

// StringRule

// bool not_empty = 1;
inline void StringRule::clear_not_empty() {
  not_empty_ = false;
}
inline bool StringRule::not_empty() const {
  // @@protoc_insertion_point(field_get:validator.StringRule.not_empty)
  return not_empty_;
}
inline void StringRule::set_not_empty(bool value) {
  
  not_empty_ = value;
  // @@protoc_insertion_point(field_set:validator.StringRule.not_empty)
}

// uint32 min_len = 2;
inline bool StringRule::has_min_len() const {
  return min_len_rule_case() == kMinLen;
}
inline void StringRule::set_has_min_len() {
  _oneof_case_[0] = kMinLen;
}
inline void StringRule::clear_min_len() {
  if (has_min_len()) {
    min_len_rule_.min_len_ = 0u;
    clear_has_min_len_rule();
  }
}
inline ::google::protobuf::uint32 StringRule::min_len() const {
  // @@protoc_insertion_point(field_get:validator.StringRule.min_len)
  if (has_min_len()) {
    return min_len_rule_.min_len_;
  }
  return 0u;
}
inline void StringRule::set_min_len(::google::protobuf::uint32 value) {
  if (!has_min_len()) {
    clear_min_len_rule();
    set_has_min_len();
  }
  min_len_rule_.min_len_ = value;
  // @@protoc_insertion_point(field_set:validator.StringRule.min_len)
}

// uint32 max_len = 3;
inline bool StringRule::has_max_len() const {
  return max_len_rule_case() == kMaxLen;
}
inline void StringRule::set_has_max_len() {
  _oneof_case_[1] = kMaxLen;
}
inline void StringRule::clear_max_len() {
  if (has_max_len()) {
    max_len_rule_.max_len_ = 0u;
    clear_has_max_len_rule();
  }
}
inline ::google::protobuf::uint32 StringRule::max_len() const {
  // @@protoc_insertion_point(field_get:validator.StringRule.max_len)
  if (has_max_len()) {
    return max_len_rule_.max_len_;
  }
  return 0u;
}
inline void StringRule::set_max_len(::google::protobuf::uint32 value) {
  if (!has_max_len()) {
    clear_max_len_rule();
    set_has_max_len();
  }
  max_len_rule_.max_len_ = value;
  // @@protoc_insertion_point(field_set:validator.StringRule.max_len)
}

// string regex_pattern = 4;
inline void StringRule::clear_regex_pattern() {
  regex_pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StringRule::regex_pattern() const {
  // @@protoc_insertion_point(field_get:validator.StringRule.regex_pattern)
  return regex_pattern_.GetNoArena();
}
inline void StringRule::set_regex_pattern(const ::std::string& value) {
  
  regex_pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:validator.StringRule.regex_pattern)
}
#if LANG_CXX11
inline void StringRule::set_regex_pattern(::std::string&& value) {
  
  regex_pattern_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:validator.StringRule.regex_pattern)
}
#endif
inline void StringRule::set_regex_pattern(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  regex_pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:validator.StringRule.regex_pattern)
}
inline void StringRule::set_regex_pattern(const char* value, size_t size) {
  
  regex_pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:validator.StringRule.regex_pattern)
}
inline ::std::string* StringRule::mutable_regex_pattern() {
  
  // @@protoc_insertion_point(field_mutable:validator.StringRule.regex_pattern)
  return regex_pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringRule::release_regex_pattern() {
  // @@protoc_insertion_point(field_release:validator.StringRule.regex_pattern)
  
  return regex_pattern_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringRule::set_allocated_regex_pattern(::std::string* regex_pattern) {
  if (regex_pattern != NULL) {
    
  } else {
    
  }
  regex_pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), regex_pattern);
  // @@protoc_insertion_point(field_set_allocated:validator.StringRule.regex_pattern)
}

inline bool StringRule::has_min_len_rule() const {
  return min_len_rule_case() != MIN_LEN_RULE_NOT_SET;
}
inline void StringRule::clear_has_min_len_rule() {
  _oneof_case_[0] = MIN_LEN_RULE_NOT_SET;
}
inline bool StringRule::has_max_len_rule() const {
  return max_len_rule_case() != MAX_LEN_RULE_NOT_SET;
}
inline void StringRule::clear_has_max_len_rule() {
  _oneof_case_[1] = MAX_LEN_RULE_NOT_SET;
}
inline StringRule::MinLenRuleCase StringRule::min_len_rule_case() const {
  return StringRule::MinLenRuleCase(_oneof_case_[0]);
}
inline StringRule::MaxLenRuleCase StringRule::max_len_rule_case() const {
  return StringRule::MaxLenRuleCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// EnumRule

// repeated int32 in = 1;
inline int EnumRule::in_size() const {
  return in_.size();
}
inline void EnumRule::clear_in() {
  in_.Clear();
}
inline ::google::protobuf::int32 EnumRule::in(int index) const {
  // @@protoc_insertion_point(field_get:validator.EnumRule.in)
  return in_.Get(index);
}
inline void EnumRule::set_in(int index, ::google::protobuf::int32 value) {
  in_.Set(index, value);
  // @@protoc_insertion_point(field_set:validator.EnumRule.in)
}
inline void EnumRule::add_in(::google::protobuf::int32 value) {
  in_.Add(value);
  // @@protoc_insertion_point(field_add:validator.EnumRule.in)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EnumRule::in() const {
  // @@protoc_insertion_point(field_list:validator.EnumRule.in)
  return in_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EnumRule::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:validator.EnumRule.in)
  return &in_;
}

// -------------------------------------------------------------------

// ArrayRule

// bool not_empty = 1;
inline void ArrayRule::clear_not_empty() {
  not_empty_ = false;
}
inline bool ArrayRule::not_empty() const {
  // @@protoc_insertion_point(field_get:validator.ArrayRule.not_empty)
  return not_empty_;
}
inline void ArrayRule::set_not_empty(bool value) {
  
  not_empty_ = value;
  // @@protoc_insertion_point(field_set:validator.ArrayRule.not_empty)
}

// uint32 min_len = 2;
inline bool ArrayRule::has_min_len() const {
  return min_len_rule_case() == kMinLen;
}
inline void ArrayRule::set_has_min_len() {
  _oneof_case_[0] = kMinLen;
}
inline void ArrayRule::clear_min_len() {
  if (has_min_len()) {
    min_len_rule_.min_len_ = 0u;
    clear_has_min_len_rule();
  }
}
inline ::google::protobuf::uint32 ArrayRule::min_len() const {
  // @@protoc_insertion_point(field_get:validator.ArrayRule.min_len)
  if (has_min_len()) {
    return min_len_rule_.min_len_;
  }
  return 0u;
}
inline void ArrayRule::set_min_len(::google::protobuf::uint32 value) {
  if (!has_min_len()) {
    clear_min_len_rule();
    set_has_min_len();
  }
  min_len_rule_.min_len_ = value;
  // @@protoc_insertion_point(field_set:validator.ArrayRule.min_len)
}

// uint32 max_len = 3;
inline bool ArrayRule::has_max_len() const {
  return max_len_rule_case() == kMaxLen;
}
inline void ArrayRule::set_has_max_len() {
  _oneof_case_[1] = kMaxLen;
}
inline void ArrayRule::clear_max_len() {
  if (has_max_len()) {
    max_len_rule_.max_len_ = 0u;
    clear_has_max_len_rule();
  }
}
inline ::google::protobuf::uint32 ArrayRule::max_len() const {
  // @@protoc_insertion_point(field_get:validator.ArrayRule.max_len)
  if (has_max_len()) {
    return max_len_rule_.max_len_;
  }
  return 0u;
}
inline void ArrayRule::set_max_len(::google::protobuf::uint32 value) {
  if (!has_max_len()) {
    clear_max_len_rule();
    set_has_max_len();
  }
  max_len_rule_.max_len_ = value;
  // @@protoc_insertion_point(field_set:validator.ArrayRule.max_len)
}

inline bool ArrayRule::has_min_len_rule() const {
  return min_len_rule_case() != MIN_LEN_RULE_NOT_SET;
}
inline void ArrayRule::clear_has_min_len_rule() {
  _oneof_case_[0] = MIN_LEN_RULE_NOT_SET;
}
inline bool ArrayRule::has_max_len_rule() const {
  return max_len_rule_case() != MAX_LEN_RULE_NOT_SET;
}
inline void ArrayRule::clear_has_max_len_rule() {
  _oneof_case_[1] = MAX_LEN_RULE_NOT_SET;
}
inline ArrayRule::MinLenRuleCase ArrayRule::min_len_rule_case() const {
  return ArrayRule::MinLenRuleCase(_oneof_case_[0]);
}
inline ArrayRule::MaxLenRuleCase ArrayRule::max_len_rule_case() const {
  return ArrayRule::MaxLenRuleCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// ValidateRules

// .validator.Int32Rule int32 = 1;
inline bool ValidateRules::has_int32() const {
  return rule_case() == kInt32;
}
inline void ValidateRules::set_has_int32() {
  _oneof_case_[0] = kInt32;
}
inline void ValidateRules::clear_int32() {
  if (has_int32()) {
    delete rule_.int32_;
    clear_has_rule();
  }
}
inline const ::validator::Int32Rule& ValidateRules::_internal_int32() const {
  return *rule_.int32_;
}
inline ::validator::Int32Rule* ValidateRules::release_int32() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.int32)
  if (has_int32()) {
    clear_has_rule();
      ::validator::Int32Rule* temp = rule_.int32_;
    rule_.int32_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::Int32Rule& ValidateRules::int32() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.int32)
  return has_int32()
      ? *rule_.int32_
      : *reinterpret_cast< ::validator::Int32Rule*>(&::validator::_Int32Rule_default_instance_);
}
inline ::validator::Int32Rule* ValidateRules::mutable_int32() {
  if (!has_int32()) {
    clear_rule();
    set_has_int32();
    rule_.int32_ = CreateMaybeMessage< ::validator::Int32Rule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.int32)
  return rule_.int32_;
}

// .validator.Int64Rule int64 = 2;
inline bool ValidateRules::has_int64() const {
  return rule_case() == kInt64;
}
inline void ValidateRules::set_has_int64() {
  _oneof_case_[0] = kInt64;
}
inline void ValidateRules::clear_int64() {
  if (has_int64()) {
    delete rule_.int64_;
    clear_has_rule();
  }
}
inline const ::validator::Int64Rule& ValidateRules::_internal_int64() const {
  return *rule_.int64_;
}
inline ::validator::Int64Rule* ValidateRules::release_int64() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.int64)
  if (has_int64()) {
    clear_has_rule();
      ::validator::Int64Rule* temp = rule_.int64_;
    rule_.int64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::Int64Rule& ValidateRules::int64() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.int64)
  return has_int64()
      ? *rule_.int64_
      : *reinterpret_cast< ::validator::Int64Rule*>(&::validator::_Int64Rule_default_instance_);
}
inline ::validator::Int64Rule* ValidateRules::mutable_int64() {
  if (!has_int64()) {
    clear_rule();
    set_has_int64();
    rule_.int64_ = CreateMaybeMessage< ::validator::Int64Rule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.int64)
  return rule_.int64_;
}

// .validator.UInt32Rule uint32 = 3;
inline bool ValidateRules::has_uint32() const {
  return rule_case() == kUint32;
}
inline void ValidateRules::set_has_uint32() {
  _oneof_case_[0] = kUint32;
}
inline void ValidateRules::clear_uint32() {
  if (has_uint32()) {
    delete rule_.uint32_;
    clear_has_rule();
  }
}
inline const ::validator::UInt32Rule& ValidateRules::_internal_uint32() const {
  return *rule_.uint32_;
}
inline ::validator::UInt32Rule* ValidateRules::release_uint32() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.uint32)
  if (has_uint32()) {
    clear_has_rule();
      ::validator::UInt32Rule* temp = rule_.uint32_;
    rule_.uint32_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::UInt32Rule& ValidateRules::uint32() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.uint32)
  return has_uint32()
      ? *rule_.uint32_
      : *reinterpret_cast< ::validator::UInt32Rule*>(&::validator::_UInt32Rule_default_instance_);
}
inline ::validator::UInt32Rule* ValidateRules::mutable_uint32() {
  if (!has_uint32()) {
    clear_rule();
    set_has_uint32();
    rule_.uint32_ = CreateMaybeMessage< ::validator::UInt32Rule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.uint32)
  return rule_.uint32_;
}

// .validator.UInt64Rule uint64 = 4;
inline bool ValidateRules::has_uint64() const {
  return rule_case() == kUint64;
}
inline void ValidateRules::set_has_uint64() {
  _oneof_case_[0] = kUint64;
}
inline void ValidateRules::clear_uint64() {
  if (has_uint64()) {
    delete rule_.uint64_;
    clear_has_rule();
  }
}
inline const ::validator::UInt64Rule& ValidateRules::_internal_uint64() const {
  return *rule_.uint64_;
}
inline ::validator::UInt64Rule* ValidateRules::release_uint64() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.uint64)
  if (has_uint64()) {
    clear_has_rule();
      ::validator::UInt64Rule* temp = rule_.uint64_;
    rule_.uint64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::UInt64Rule& ValidateRules::uint64() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.uint64)
  return has_uint64()
      ? *rule_.uint64_
      : *reinterpret_cast< ::validator::UInt64Rule*>(&::validator::_UInt64Rule_default_instance_);
}
inline ::validator::UInt64Rule* ValidateRules::mutable_uint64() {
  if (!has_uint64()) {
    clear_rule();
    set_has_uint64();
    rule_.uint64_ = CreateMaybeMessage< ::validator::UInt64Rule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.uint64)
  return rule_.uint64_;
}

// .validator.FloatRule float = 5;
inline bool ValidateRules::has_float_() const {
  return rule_case() == kFloat;
}
inline void ValidateRules::set_has_float_() {
  _oneof_case_[0] = kFloat;
}
inline void ValidateRules::clear_float_() {
  if (has_float_()) {
    delete rule_.float__;
    clear_has_rule();
  }
}
inline const ::validator::FloatRule& ValidateRules::_internal_float_() const {
  return *rule_.float__;
}
inline ::validator::FloatRule* ValidateRules::release_float_() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.float)
  if (has_float_()) {
    clear_has_rule();
      ::validator::FloatRule* temp = rule_.float__;
    rule_.float__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::FloatRule& ValidateRules::float_() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.float)
  return has_float_()
      ? *rule_.float__
      : *reinterpret_cast< ::validator::FloatRule*>(&::validator::_FloatRule_default_instance_);
}
inline ::validator::FloatRule* ValidateRules::mutable_float_() {
  if (!has_float_()) {
    clear_rule();
    set_has_float_();
    rule_.float__ = CreateMaybeMessage< ::validator::FloatRule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.float)
  return rule_.float__;
}

// .validator.DoubleRule double = 6;
inline bool ValidateRules::has_double_() const {
  return rule_case() == kDouble;
}
inline void ValidateRules::set_has_double_() {
  _oneof_case_[0] = kDouble;
}
inline void ValidateRules::clear_double_() {
  if (has_double_()) {
    delete rule_.double__;
    clear_has_rule();
  }
}
inline const ::validator::DoubleRule& ValidateRules::_internal_double_() const {
  return *rule_.double__;
}
inline ::validator::DoubleRule* ValidateRules::release_double_() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.double)
  if (has_double_()) {
    clear_has_rule();
      ::validator::DoubleRule* temp = rule_.double__;
    rule_.double__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::DoubleRule& ValidateRules::double_() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.double)
  return has_double_()
      ? *rule_.double__
      : *reinterpret_cast< ::validator::DoubleRule*>(&::validator::_DoubleRule_default_instance_);
}
inline ::validator::DoubleRule* ValidateRules::mutable_double_() {
  if (!has_double_()) {
    clear_rule();
    set_has_double_();
    rule_.double__ = CreateMaybeMessage< ::validator::DoubleRule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.double)
  return rule_.double__;
}

// .validator.StringRule string = 7;
inline bool ValidateRules::has_string() const {
  return rule_case() == kString;
}
inline void ValidateRules::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void ValidateRules::clear_string() {
  if (has_string()) {
    delete rule_.string_;
    clear_has_rule();
  }
}
inline const ::validator::StringRule& ValidateRules::_internal_string() const {
  return *rule_.string_;
}
inline ::validator::StringRule* ValidateRules::release_string() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.string)
  if (has_string()) {
    clear_has_rule();
      ::validator::StringRule* temp = rule_.string_;
    rule_.string_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::StringRule& ValidateRules::string() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.string)
  return has_string()
      ? *rule_.string_
      : *reinterpret_cast< ::validator::StringRule*>(&::validator::_StringRule_default_instance_);
}
inline ::validator::StringRule* ValidateRules::mutable_string() {
  if (!has_string()) {
    clear_rule();
    set_has_string();
    rule_.string_ = CreateMaybeMessage< ::validator::StringRule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.string)
  return rule_.string_;
}

// .validator.EnumRule enum = 8;
inline bool ValidateRules::has_enum_() const {
  return rule_case() == kEnum;
}
inline void ValidateRules::set_has_enum_() {
  _oneof_case_[0] = kEnum;
}
inline void ValidateRules::clear_enum_() {
  if (has_enum_()) {
    delete rule_.enum__;
    clear_has_rule();
  }
}
inline const ::validator::EnumRule& ValidateRules::_internal_enum_() const {
  return *rule_.enum__;
}
inline ::validator::EnumRule* ValidateRules::release_enum_() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.enum)
  if (has_enum_()) {
    clear_has_rule();
      ::validator::EnumRule* temp = rule_.enum__;
    rule_.enum__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::EnumRule& ValidateRules::enum_() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.enum)
  return has_enum_()
      ? *rule_.enum__
      : *reinterpret_cast< ::validator::EnumRule*>(&::validator::_EnumRule_default_instance_);
}
inline ::validator::EnumRule* ValidateRules::mutable_enum_() {
  if (!has_enum_()) {
    clear_rule();
    set_has_enum_();
    rule_.enum__ = CreateMaybeMessage< ::validator::EnumRule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.enum)
  return rule_.enum__;
}

// .validator.ArrayRule array = 9;
inline bool ValidateRules::has_array() const {
  return rule_case() == kArray;
}
inline void ValidateRules::set_has_array() {
  _oneof_case_[0] = kArray;
}
inline void ValidateRules::clear_array() {
  if (has_array()) {
    delete rule_.array_;
    clear_has_rule();
  }
}
inline const ::validator::ArrayRule& ValidateRules::_internal_array() const {
  return *rule_.array_;
}
inline ::validator::ArrayRule* ValidateRules::release_array() {
  // @@protoc_insertion_point(field_release:validator.ValidateRules.array)
  if (has_array()) {
    clear_has_rule();
      ::validator::ArrayRule* temp = rule_.array_;
    rule_.array_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::validator::ArrayRule& ValidateRules::array() const {
  // @@protoc_insertion_point(field_get:validator.ValidateRules.array)
  return has_array()
      ? *rule_.array_
      : *reinterpret_cast< ::validator::ArrayRule*>(&::validator::_ArrayRule_default_instance_);
}
inline ::validator::ArrayRule* ValidateRules::mutable_array() {
  if (!has_array()) {
    clear_rule();
    set_has_array();
    rule_.array_ = CreateMaybeMessage< ::validator::ArrayRule >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:validator.ValidateRules.array)
  return rule_.array_;
}

inline bool ValidateRules::has_rule() const {
  return rule_case() != RULE_NOT_SET;
}
inline void ValidateRules::clear_has_rule() {
  _oneof_case_[0] = RULE_NOT_SET;
}
inline ValidateRules::RuleCase ValidateRules::rule_case() const {
  return ValidateRules::RuleCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace validator

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_validator_2eproto
